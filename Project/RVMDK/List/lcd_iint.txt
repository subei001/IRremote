; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\lcd_iint.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\lcd_iint.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\User\inc -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\RVMDK -ID:\keil\ARM\RV31\INC -ID:\keil\ARM\CMSIS\Include -ID:\keil\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=528 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\lcd_iint.crf ..\..\User\src\LCD_Iint.c]
                          THUMB

                          AREA ||i.BGR2RGB||, CODE, READONLY, ALIGN=1

                  BGR2RGB PROC
;;;180    
;;;181    unsigned short BGR2RGB(unsigned short c)
000000  b530              PUSH     {r4,r5,lr}
;;;182    {
000002  4601              MOV      r1,r0
;;;183        u16  r, g, b, rgb;
;;;184    
;;;185        b = (c>>0)  & 0x1f;
000004  f001041f          AND      r4,r1,#0x1f
;;;186        g = (c>>5)  & 0x3f;
000008  f3c11345          UBFX     r3,r1,#5,#6
;;;187        r = (c>>11) & 0x1f;
00000c  0aca              LSRS     r2,r1,#11
;;;188    
;;;189        rgb =  (b<<11) + (g<<5) + (r<<0);
00000e  02e5              LSLS     r5,r4,#11
000010  eb051543          ADD      r5,r5,r3,LSL #5
000014  4415              ADD      r5,r5,r2
000016  b2a8              UXTH     r0,r5
;;;190    
;;;191        return( rgb );
;;;192    }
000018  bd30              POP      {r4,r5,pc}
;;;193    
                          ENDP


                          AREA ||i.delay||, CODE, READONLY, ALIGN=1

                  delay PROC
;;;25     
;;;26     static void delay(int cnt)
000000  b508              PUSH     {r3,lr}
;;;27     {
;;;28         volatile unsigned int dl;
;;;29         while(cnt--)
000002  e009              B        |L2.24|
                  |L2.4|
;;;30         {
;;;31             for(dl=0; dl<500; dl++);
000004  2100              MOVS     r1,#0
000006  9100              STR      r1,[sp,#0]
000008  e002              B        |L2.16|
                  |L2.10|
00000a  9900              LDR      r1,[sp,#0]
00000c  1c49              ADDS     r1,r1,#1
00000e  9100              STR      r1,[sp,#0]
                  |L2.16|
000010  9900              LDR      r1,[sp,#0]
000012  f5b17ffa          CMP      r1,#0x1f4
000016  d3f8              BCC      |L2.10|
                  |L2.24|
000018  1e01              SUBS     r1,r0,#0              ;29
00001a  f1a00001          SUB      r0,r0,#1              ;29
00001e  d1f1              BNE      |L2.4|
;;;32         }
;;;33     }
000020  bd08              POP      {r3,pc}
;;;34     
                          ENDP


                          AREA ||i.lcd_Initializtion||, CODE, READONLY, ALIGN=2

                  lcd_Initializtion PROC
;;;223    
;;;224    void lcd_Initializtion(void)
000000  b570              PUSH     {r4-r6,lr}
;;;225    {
;;;226        lcd_port_init();
000002  f7fffffe          BL       lcd_port_init
;;;227        delay(1500);
000006  f24050dc          MOV      r0,#0x5dc
00000a  f7fffffe          BL       delay
;;;228        deviceid = read_reg(0x00);
00000e  2400              MOVS     r4,#0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       write_cmd
000016  bf00              NOP      
000018  2000              MOVS     r0,#0
00001a  f44f5180          MOV      r1,#0x1000
00001e  4a7e              LDR      r2,|L3.536|
000020  6011              STR      r1,[r2,#0]
000022  f04f3144          MOV      r1,#0x44444444
000026  4a7d              LDR      r2,|L3.540|
000028  6011              STR      r1,[r2,#0]
00002a  1f12              SUBS     r2,r2,#4
00002c  6011              STR      r1,[r2,#0]
00002e  f44f4100          MOV      r1,#0x8000
000032  4a79              LDR      r2,|L3.536|
000034  6011              STR      r1,[r2,#0]
000036  4979              LDR      r1,|L3.540|
000038  1d09              ADDS     r1,r1,#4
00003a  6809              LDR      r1,[r1,#0]
00003c  b288              UXTH     r0,r1
00003e  4977              LDR      r1,|L3.540|
000040  1d09              ADDS     r1,r1,#4
000042  6809              LDR      r1,[r1,#0]
000044  b288              UXTH     r0,r1
000046  f44f4100          MOV      r1,#0x8000
00004a  1f12              SUBS     r2,r2,#4
00004c  6011              STR      r1,[r2,#0]
00004e  f04f3133          MOV      r1,#0x33333333
000052  4a72              LDR      r2,|L3.540|
000054  6011              STR      r1,[r2,#0]
000056  1f12              SUBS     r2,r2,#4
000058  6011              STR      r1,[r2,#0]
00005a  1491              ASRS     r1,r2,#18
00005c  4a6e              LDR      r2,|L3.536|
00005e  1f12              SUBS     r2,r2,#4
000060  6011              STR      r1,[r2,#0]
000062  bf00              NOP      
000064  4605              MOV      r5,r0
000066  bf00              NOP      
000068  486d              LDR      r0,|L3.544|
00006a  8005              STRH     r5,[r0,#0]
;;;229    	
;;;230    	if( deviceid == 0x8989 )
00006c  8800              LDRH     r0,[r0,#0]  ; deviceid
00006e  f6481189          MOV      r1,#0x8989
000072  4288              CMP      r0,r1
000074  d17e              BNE      |L3.372|
;;;231        {
;;;232            // power supply setting
;;;233            // set R07h at 0021h (GON=1,DTE=0,D[1:0]=01)
;;;234            write_reg(0x0007,0x0021);
000076  2121              MOVS     r1,#0x21
000078  2007              MOVS     r0,#7
00007a  f7fffffe          BL       write_reg
;;;235            // set R00h at 0001h (OSCEN=1)
;;;236            write_reg(0x0000,0x0001);	
00007e  2101              MOVS     r1,#1
000080  2000              MOVS     r0,#0
000082  f7fffffe          BL       write_reg
;;;237            // set R07h at 0023h (GON=1,DTE=0,D[1:0]=11)
;;;238            write_reg(0x0007,0x0023);
000086  2123              MOVS     r1,#0x23
000088  2007              MOVS     r0,#7
00008a  f7fffffe          BL       write_reg
;;;239            // set R10h at 0000h (Exit sleep mode)
;;;240            write_reg(0x0010,0x0000); 
00008e  2100              MOVS     r1,#0
000090  2010              MOVS     r0,#0x10
000092  f7fffffe          BL       write_reg
;;;241            // Wait 30ms
;;;242            delay(3000);
000096  f64030b8          MOV      r0,#0xbb8
00009a  f7fffffe          BL       delay
;;;243            // set R07h at 0033h (GON=1,DTE=1,D[1:0]=11)
;;;244            write_reg(0x0007,0x0033); 
00009e  2133              MOVS     r1,#0x33
0000a0  2007              MOVS     r0,#7
0000a2  f7fffffe          BL       write_reg
;;;245            // Entry mode setting (R11h)
;;;246            // R11H Entry mode
;;;247            // vsmode DFM1 DFM0 TRANS OEDef WMode DMode1 DMode0 TY1 TY0 ID1 ID0 AM LG2 LG2 LG0
;;;248            //   0     1    1     0     0     0     0      0     0   1   1   1  *   0   0   0
;;;249            write_reg(0x0011,0x6070);
0000a6  f2460170          MOV      r1,#0x6070
0000aa  2011              MOVS     r0,#0x11
0000ac  f7fffffe          BL       write_reg
;;;250            // LCD driver AC setting (R02h)
;;;251            write_reg(0x0002,0x0600);
0000b0  f44f61c0          MOV      r1,#0x600
0000b4  2002              MOVS     r0,#2
0000b6  f7fffffe          BL       write_reg
;;;252            // power control 1
;;;253            // DCT3 DCT2 DCT1 DCT0 BT2 BT1 BT0 0 DC3 DC2 DC1 DC0 AP2 AP1 AP0 0
;;;254            // 1     0    1    0    1   0   0  0  1   0   1   0   0   1   0  0
;;;255            // DCT[3:0] fosc/4 BT[2:0]  DC{3:0] fosc/4
;;;256            write_reg(0x0003,0x0804);//0xA8A4
0000ba  f6400104          MOV      r1,#0x804
0000be  2003              MOVS     r0,#3
0000c0  f7fffffe          BL       write_reg
;;;257            write_reg(0x000C,0x0000);//
0000c4  2100              MOVS     r1,#0
0000c6  200c              MOVS     r0,#0xc
0000c8  f7fffffe          BL       write_reg
;;;258            write_reg(0x000D,0x080C);//
0000cc  f640010c          MOV      r1,#0x80c
0000d0  200d              MOVS     r0,#0xd
0000d2  f7fffffe          BL       write_reg
;;;259            // power control 4
;;;260            // 0 0 VCOMG VDV4 VDV3 VDV2 VDV1 VDV0 0 0 0 0 0 0 0 0
;;;261            // 0 0   1    0    1    0    1    1   0 0 0 0 0 0 0 0
;;;262            write_reg(0x000E,0x2900);
0000d6  f44f5124          MOV      r1,#0x2900
0000da  200e              MOVS     r0,#0xe
0000dc  f7fffffe          BL       write_reg
;;;263            write_reg(0x001E,0x00B8);
0000e0  21b8              MOVS     r1,#0xb8
0000e2  201e              MOVS     r0,#0x1e
0000e4  f7fffffe          BL       write_reg
;;;264            write_reg(0x0001,0x2B3F);//驱动输出控制320*240  0x6B3F
0000e8  f642313f          MOV      r1,#0x2b3f
0000ec  2001              MOVS     r0,#1
0000ee  f7fffffe          BL       write_reg
;;;265            write_reg(0x0010,0x0000);
0000f2  2100              MOVS     r1,#0
0000f4  2010              MOVS     r0,#0x10
0000f6  f7fffffe          BL       write_reg
;;;266            write_reg(0x0005,0x0000);
0000fa  2100              MOVS     r1,#0
0000fc  2005              MOVS     r0,#5
0000fe  f7fffffe          BL       write_reg
;;;267            write_reg(0x0006,0x0000);
000102  2100              MOVS     r1,#0
000104  2006              MOVS     r0,#6
000106  f7fffffe          BL       write_reg
;;;268            write_reg(0x0016,0xEF1C);
00010a  f64e711c          MOV      r1,#0xef1c
00010e  2016              MOVS     r0,#0x16
000110  f7fffffe          BL       write_reg
;;;269            write_reg(0x0017,0x0003);
000114  2103              MOVS     r1,#3
000116  2017              MOVS     r0,#0x17
000118  f7fffffe          BL       write_reg
;;;270            write_reg(0x0007,0x0233);//0x0233
00011c  f2402133          MOV      r1,#0x233
000120  2007              MOVS     r0,#7
000122  f7fffffe          BL       write_reg
;;;271            write_reg(0x000B,0x0000|(3<<6));
000126  21c0              MOVS     r1,#0xc0
000128  200b              MOVS     r0,#0xb
00012a  f7fffffe          BL       write_reg
;;;272            write_reg(0x000F,0x0000);//扫描开始地址
00012e  2100              MOVS     r1,#0
000130  200f              MOVS     r0,#0xf
000132  f7fffffe          BL       write_reg
;;;273            write_reg(0x0041,0x0000);
000136  2100              MOVS     r1,#0
000138  2041              MOVS     r0,#0x41
00013a  f7fffffe          BL       write_reg
;;;274            write_reg(0x0042,0x0000);
00013e  2100              MOVS     r1,#0
000140  2042              MOVS     r0,#0x42
000142  f7fffffe          BL       write_reg
;;;275            write_reg(0x0048,0x0000);
000146  2100              MOVS     r1,#0
000148  2048              MOVS     r0,#0x48
00014a  f7fffffe          BL       write_reg
;;;276            write_reg(0x0049,0x013F);
00014e  f240113f          MOV      r1,#0x13f
000152  2049              MOVS     r0,#0x49
000154  f7fffffe          BL       write_reg
;;;277            write_reg(0x004A,0x0000);
000158  2100              MOVS     r1,#0
00015a  204a              MOVS     r0,#0x4a
00015c  f7fffffe          BL       write_reg
;;;278            write_reg(0x004B,0x0000);
000160  2100              MOVS     r1,#0
000162  204b              MOVS     r0,#0x4b
000164  f7fffffe          BL       write_reg
;;;279            write_reg(0x0044,0xEF00);
000168  f44f416f          MOV      r1,#0xef00
00016c  2044              MOVS     r0,#0x44
00016e  f7fffffe          BL       write_reg
;;;280            write_reg(0x0045,0x0000);
000172  e000              B        |L3.374|
                  |L3.372|
000174  e04f              B        |L3.534|
                  |L3.374|
000176  2100              MOVS     r1,#0
000178  2045              MOVS     r0,#0x45
00017a  f7fffffe          BL       write_reg
;;;281            write_reg(0x0046,0x013F);
00017e  f240113f          MOV      r1,#0x13f
000182  2046              MOVS     r0,#0x46
000184  f7fffffe          BL       write_reg
;;;282            write_reg(0x0030,0x0707);
000188  f2407107          MOV      r1,#0x707
00018c  2030              MOVS     r0,#0x30
00018e  f7fffffe          BL       write_reg
;;;283            write_reg(0x0031,0x0204);
000192  f44f7101          MOV      r1,#0x204
000196  2031              MOVS     r0,#0x31
000198  f7fffffe          BL       write_reg
;;;284            write_reg(0x0032,0x0204);
00019c  f44f7101          MOV      r1,#0x204
0001a0  2032              MOVS     r0,#0x32
0001a2  f7fffffe          BL       write_reg
;;;285            write_reg(0x0033,0x0502);
0001a6  f2405102          MOV      r1,#0x502
0001aa  2033              MOVS     r0,#0x33
0001ac  f7fffffe          BL       write_reg
;;;286            write_reg(0x0034,0x0507);
0001b0  f2405107          MOV      r1,#0x507
0001b4  2034              MOVS     r0,#0x34
0001b6  f7fffffe          BL       write_reg
;;;287            write_reg(0x0035,0x0204);
0001ba  f44f7101          MOV      r1,#0x204
0001be  2035              MOVS     r0,#0x35
0001c0  f7fffffe          BL       write_reg
;;;288            write_reg(0x0036,0x0204);
0001c4  f44f7101          MOV      r1,#0x204
0001c8  2036              MOVS     r0,#0x36
0001ca  f7fffffe          BL       write_reg
;;;289            write_reg(0x0037,0x0502);
0001ce  f2405102          MOV      r1,#0x502
0001d2  2037              MOVS     r0,#0x37
0001d4  f7fffffe          BL       write_reg
;;;290            write_reg(0x003A,0x0302);
0001d8  f2403102          MOV      r1,#0x302
0001dc  203a              MOVS     r0,#0x3a
0001de  f7fffffe          BL       write_reg
;;;291            write_reg(0x003B,0x0302);
0001e2  f2403102          MOV      r1,#0x302
0001e6  203b              MOVS     r0,#0x3b
0001e8  f7fffffe          BL       write_reg
;;;292            write_reg(0x0023,0x0000);
0001ec  2100              MOVS     r1,#0
0001ee  2023              MOVS     r0,#0x23
0001f0  f7fffffe          BL       write_reg
;;;293            write_reg(0x0024,0x0000);
0001f4  2100              MOVS     r1,#0
0001f6  2024              MOVS     r0,#0x24
0001f8  f7fffffe          BL       write_reg
;;;294            write_reg(0x0025,0x8000);   // 65hz
0001fc  f44f4100          MOV      r1,#0x8000
000200  2025              MOVS     r0,#0x25
000202  f7fffffe          BL       write_reg
;;;295            write_reg(0x004f,0);        // 行首址0
000206  2100              MOVS     r1,#0
000208  204f              MOVS     r0,#0x4f
00020a  f7fffffe          BL       write_reg
;;;296            write_reg(0x004e,0);        // 列首址0	  
00020e  2100              MOVS     r1,#0
000210  204e              MOVS     r0,#0x4e
000212  f7fffffe          BL       write_reg
                  |L3.534|
;;;297        }
;;;298    }
000216  bd70              POP      {r4-r6,pc}
;;;299    
                          ENDP

                  |L3.536|
                          DCD      0x40011414
                  |L3.540|
                          DCD      0x40011804
                  |L3.544|
                          DCD      deviceid

                          AREA ||i.lcd_SetCursor||, CODE, READONLY, ALIGN=2

                  lcd_SetCursor PROC
;;;193    
;;;194    void lcd_SetCursor(unsigned int x,unsigned int y)
000000  b570              PUSH     {r4-r6,lr}
;;;195    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;196        // SSD1289 控制器的屏使用不同的寄存器
;;;197        if( deviceid == 0x8989 )
000006  480b              LDR      r0,|L4.52|
000008  8800              LDRH     r0,[r0,#0]  ; deviceid
00000a  f6481189          MOV      r1,#0x8989
00000e  4288              CMP      r0,r1
000010  d107              BNE      |L4.34|
;;;198        {
;;;199            write_reg(0x004e,x);    /* 0-239 */
000012  b2a1              UXTH     r1,r4
000014  204e              MOVS     r0,#0x4e
000016  f7fffffe          BL       write_reg
;;;200            write_reg(0x004f,y);    /* 0-319 */
00001a  b2a9              UXTH     r1,r5
00001c  204f              MOVS     r0,#0x4f
00001e  f7fffffe          BL       write_reg
                  |L4.34|
;;;201        }
;;;202        write_reg(32,x);    /* 0-239 */
000022  b2a1              UXTH     r1,r4
000024  2020              MOVS     r0,#0x20
000026  f7fffffe          BL       write_reg
;;;203        write_reg(33,y);    /* 0-319 */
00002a  b2a9              UXTH     r1,r5
00002c  2021              MOVS     r0,#0x21
00002e  f7fffffe          BL       write_reg
;;;204    }
000032  bd70              POP      {r4-r6,pc}
;;;205    /****************************************************************************
                          ENDP

                  |L4.52|
                          DCD      deviceid

                          AREA ||i.lcd_clear||, CODE, READONLY, ALIGN=1

                  lcd_clear PROC
;;;212    ****************************************************************************/
;;;213    void lcd_clear(unsigned short Color)
000000  b570              PUSH     {r4-r6,lr}
;;;214    {
000002  4605              MOV      r5,r0
;;;215        unsigned int index=0;
000004  2400              MOVS     r4,#0
;;;216        lcd_SetCursor(0,0);
000006  2100              MOVS     r1,#0
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       lcd_SetCursor
;;;217        rw_data_prepare();                      /* Prepare to write GRAM */
00000e  f7fffffe          BL       rw_data_prepare
;;;218        for (index=0; index<(LCD_WIDTH*LCD_HEIGHT); index++)
000012  bf00              NOP      
000014  e003              B        |L5.30|
                  |L5.22|
;;;219        {
;;;220            write_data(Color);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       write_data
00001c  1c64              ADDS     r4,r4,#1              ;218
                  |L5.30|
00001e  f5b43f96          CMP      r4,#0x12c00           ;218
000022  d3f8              BCC      |L5.22|
;;;221        }
;;;222    }
000024  bd70              POP      {r4-r6,pc}
;;;223    
                          ENDP


                          AREA ||i.lcd_getdeviceid||, CODE, READONLY, ALIGN=2

                  lcd_getdeviceid PROC
;;;175    //返回LCD的ID
;;;176    unsigned int lcd_getdeviceid(void)
000000  4801              LDR      r0,|L6.8|
;;;177    {
;;;178        return deviceid;
000002  8800              LDRH     r0,[r0,#0]  ; deviceid
;;;179    }
000004  4770              BX       lr
;;;180    
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      deviceid

                          AREA ||i.lcd_port_init||, CODE, READONLY, ALIGN=2

                  lcd_port_init PROC
;;;47     
;;;48     static void lcd_port_init(void)
000000  b508              PUSH     {r3,lr}
;;;49     {
;;;50         GPIO_InitTypeDef GPIO_InitStructure;
;;;51         /*开启相应时钟 */
;;;52         RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB|
000002  2101              MOVS     r1,#1
000004  207c              MOVS     r0,#0x7c
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;53                                RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD|RCC_APB2Periph_GPIOE, ENABLE);
;;;54         /*所有Lcd引脚配置为推挽输出*/
;;;55         /*16位数据*/
;;;56         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
00000a  f64f70ff          MOV      r0,#0xffff
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;57         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000012  2003              MOVS     r0,#3
000014  f88d0002          STRB     r0,[sp,#2]
;;;58         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000018  2010              MOVS     r0,#0x10
00001a  f88d0003          STRB     r0,[sp,#3]
;;;59         GPIO_Init(GPIOE, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  480b              LDR      r0,|L7.80|
000022  f7fffffe          BL       GPIO_Init
;;;60         /*控制脚*/
;;;61         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15;
000026  f44f4070          MOV      r0,#0xf000
00002a  f8ad0000          STRH     r0,[sp,#0]
;;;62         GPIO_Init(GPIOD, &GPIO_InitStructure);
00002e  4669              MOV      r1,sp
000030  4808              LDR      r0,|L7.84|
000032  f7fffffe          BL       GPIO_Init
;;;63     
;;;64         set_CS();
000036  f44f5080          MOV      r0,#0x1000
00003a  4906              LDR      r1,|L7.84|
00003c  3110              ADDS     r1,r1,#0x10
00003e  6008              STR      r0,[r1,#0]
;;;65         set_RS();
000040  0040              LSLS     r0,r0,#1
000042  6008              STR      r0,[r1,#0]
;;;66         set_nRD();
000044  0080              LSLS     r0,r0,#2
000046  6008              STR      r0,[r1,#0]
;;;67         set_nWR();
000048  1040              ASRS     r0,r0,#1
00004a  6008              STR      r0,[r1,#0]
;;;68     }
00004c  bd08              POP      {r3,pc}
;;;69     
                          ENDP

00004e  0000              DCW      0x0000
                  |L7.80|
                          DCD      0x40011800
                  |L7.84|
                          DCD      0x40011400

                          AREA ||i.rt_hw_lcd_draw_hline||, CODE, READONLY, ALIGN=1

                  rt_hw_lcd_draw_hline PROC
;;;333    /* 水平线 */
;;;334    void rt_hw_lcd_draw_hline(unsigned int colour, unsigned int x1, unsigned int x2, unsigned int y)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;335    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;336        /* [5:4]-ID~ID0 [3]-AM-1垂直-0水平 */
;;;337        write_reg(0x0003,(1<<12)|(1<<5)|(1<<4) | (0<<3) );
00000c  f2410130          MOV      r1,#0x1030
000010  2003              MOVS     r0,#3
000012  f7fffffe          BL       write_reg
;;;338    
;;;339        while (x1 < x2)
000016  e009              B        |L8.44|
                  |L8.24|
;;;340        {
;;;341            lcd_SetCursor(x1, y);
000018  4639              MOV      r1,r7
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       lcd_SetCursor
;;;342       		rw_data_prepare(); /* Prepare to write GRAM */
000020  f7fffffe          BL       rw_data_prepare
;;;343    		write_data(colour);
000024  b2a8              UXTH     r0,r5
000026  f7fffffe          BL       write_data
;;;344            x1++;
00002a  1c64              ADDS     r4,r4,#1
                  |L8.44|
00002c  42b4              CMP      r4,r6                 ;339
00002e  d3f3              BCC      |L8.24|
;;;345        }
;;;346    }
000030  e8bd81f0          POP      {r4-r8,pc}
;;;347    
                          ENDP


                          AREA ||i.rt_hw_lcd_draw_vline||, CODE, READONLY, ALIGN=1

                  rt_hw_lcd_draw_vline PROC
;;;348    /* 垂直线 */
;;;349    void rt_hw_lcd_draw_vline(unsigned int colour, unsigned int x, unsigned int y1, unsigned int y2)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;350    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
;;;351        /* [5:4]-ID~ID0 [3]-AM-1垂直-0水平 */
;;;352        write_reg(0x0003,(1<<12)|(1<<5)|(0<<4) | (1<<3) );
00000c  f2410128          MOV      r1,#0x1028
000010  2003              MOVS     r0,#3
000012  f7fffffe          BL       write_reg
;;;353    
;;;354        while (y1 < y2)
000016  e009              B        |L9.44|
                  |L9.24|
;;;355        {
;;;356            lcd_SetCursor(x, y1);
000018  4621              MOV      r1,r4
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       lcd_SetCursor
;;;357        	rw_data_prepare(); /* Prepare to write GRAM */
000020  f7fffffe          BL       rw_data_prepare
;;;358    		write_data(colour);
000024  b2a8              UXTH     r0,r5
000026  f7fffffe          BL       write_data
;;;359            y1++;	//每显示一色点坐标X会自动加1，但是坐标Y不会自动加1
00002a  1c64              ADDS     r4,r4,#1
                  |L9.44|
00002c  42bc              CMP      r4,r7                 ;354
00002e  d3f3              BCC      |L9.24|
;;;360        }
;;;361    }
000030  e8bd81f0          POP      {r4-r8,pc}
;;;362    
                          ENDP


                          AREA ||i.rw_data_prepare||, CODE, READONLY, ALIGN=1

                  rw_data_prepare PROC
;;;120    
;;;121    void rw_data_prepare(void)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123        write_cmd(0x22);
000002  2022              MOVS     r0,#0x22
000004  f7fffffe          BL       write_cmd
;;;124    }
000008  bd10              POP      {r4,pc}
;;;125    
                          ENDP


                          AREA ||i.write_cmd||, CODE, READONLY, ALIGN=2

                  write_cmd PROC
;;;69     
;;;70     lcd_inline void write_cmd(unsigned short cmd)
000000  f44f5180          MOV      r1,#0x1000
;;;71     {
;;;72         /**********************************
;;;73         // ** nCS      ---\________/------*
;;;74         // ** RS       ----\______/-------*
;;;75         // ** nRD      -------------------*
;;;76         // ** nWR      -----\___/---------*
;;;77         // ** DB[0-15] ------[###]--------*
;;;78         **********************************/
;;;79     
;;;80         clr_CS();
000004  4a07              LDR      r2,|L11.36|
000006  6011              STR      r1,[r2,#0]
;;;81     
;;;82         clr_RS();
000008  0049              LSLS     r1,r1,#1
00000a  6011              STR      r1,[r2,#0]
;;;83         GPIOE->ODR = cmd;
00000c  4906              LDR      r1,|L11.40|
00000e  6008              STR      r0,[r1,#0]
;;;84         clr_nWR();
000010  f44f4180          MOV      r1,#0x4000
000014  6011              STR      r1,[r2,#0]
;;;85         set_nWR();
000016  1f12              SUBS     r2,r2,#4
000018  6011              STR      r1,[r2,#0]
;;;86         set_RS();
00001a  1049              ASRS     r1,r1,#1
00001c  6011              STR      r1,[r2,#0]
;;;87     
;;;88         set_CS();
00001e  1049              ASRS     r1,r1,#1
000020  6011              STR      r1,[r2,#0]
;;;89     }
000022  4770              BX       lr
;;;90     
                          ENDP

                  |L11.36|
                          DCD      0x40011414
                  |L11.40|
                          DCD      0x4001180c

                          AREA ||i.write_data||, CODE, READONLY, ALIGN=2

                  write_data PROC
;;;125    
;;;126    void write_data(unsigned short data )
000000  f44f5180          MOV      r1,#0x1000
;;;127    {
;;;128        /**********************************
;;;129        // ** nCS      ---\________/-----**
;;;130        // ** RS       ------------------**
;;;131        // ** nRD      ------------------**
;;;132        // ** nWR      -----\___/--------**
;;;133        // ** DB[0-15] ------[###]-------**
;;;134        **********************************/
;;;135        clr_CS();
000004  4a05              LDR      r2,|L12.28|
000006  6011              STR      r1,[r2,#0]
;;;136    
;;;137        GPIOE->ODR = data;
000008  4905              LDR      r1,|L12.32|
00000a  6008              STR      r0,[r1,#0]
;;;138        clr_nWR();
00000c  f44f4180          MOV      r1,#0x4000
000010  6011              STR      r1,[r2,#0]
;;;139        set_nWR();
000012  1f12              SUBS     r2,r2,#4
000014  6011              STR      r1,[r2,#0]
;;;140    
;;;141        set_CS();
000016  1089              ASRS     r1,r1,#2
000018  6011              STR      r1,[r2,#0]
;;;142    }
00001a  4770              BX       lr
;;;143    
                          ENDP

                  |L12.28|
                          DCD      0x40011414
                  |L12.32|
                          DCD      0x4001180c

                          AREA ||i.write_reg||, CODE, READONLY, ALIGN=1

                  write_reg PROC
;;;143    
;;;144    lcd_inline void write_reg(unsigned char reg_addr,unsigned short reg_val)
000000  b570              PUSH     {r4-r6,lr}
;;;145    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;146        /*************************************************
;;;147        // ** nCS      ---\________/------\________/----**
;;;148        // ** RS       ----\______/---------------------**
;;;149        // ** nRD      ---------------------------------**
;;;150        // ** nWR      -----\___/-----------\___/-------**
;;;151        // ** DB[0-15] ------[###]-----------[###]------**
;;;152        *************************************************/
;;;153        write_cmd(reg_addr);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       write_cmd
;;;154        write_data(reg_val);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       write_data
;;;155    }
000012  bd70              POP      {r4-r6,pc}
;;;156    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  deviceid
000000  0000              DCW      0x0000
