; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\stm32f10x_fsmc.o --depend=.\Obj\stm32f10x_fsmc.d --device=DARMSTM --apcs=interwork -O3 -I..\..\User\inc -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\My_Libraries\inc -IE:\keil_MDK\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\stm32f10x_fsmc.crf ..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_fsmc.c]
                          THUMB

                          AREA ||i.FSMC_ClearFlag||, CODE, READONLY, ALIGN=1

                  FSMC_ClearFlag PROC
;;;738      */
;;;739    void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000000  f04f4220          MOV      r2,#0xa0000000
;;;740    {
;;;741     /* Check the parameters */
;;;742      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;743      assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
;;;744        
;;;745      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d103              BNE      |L1.16|
;;;746      {
;;;747        FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
000008  6e50              LDR      r0,[r2,#0x64]
00000a  4388              BICS     r0,r0,r1
00000c  6650              STR      r0,[r2,#0x64]
;;;748      }  
;;;749      else if(FSMC_Bank == FSMC_Bank3_NAND)
;;;750      {
;;;751        FSMC_Bank3->SR3 &= ~FSMC_FLAG;
;;;752      }
;;;753      /* FSMC_Bank4_PCCARD*/
;;;754      else
;;;755      {
;;;756        FSMC_Bank4->SR4 &= ~FSMC_FLAG;
;;;757      }
;;;758    }
00000e  4770              BX       lr
                  |L1.16|
000010  f5b07f80          CMP      r0,#0x100             ;749
000014  d101              BNE      |L1.26|
000016  3284              ADDS     r2,r2,#0x84           ;749
000018  e000              B        |L1.28|
                  |L1.26|
00001a  32a4              ADDS     r2,r2,#0xa4           ;751
                  |L1.28|
00001c  6810              LDR      r0,[r2,#0]            ;756
00001e  4388              BICS     r0,r0,r1              ;756
000020  6010              STR      r0,[r2,#0]            ;756
000022  4770              BX       lr
;;;759    
                          ENDP


                          AREA ||i.FSMC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  FSMC_ClearITPendingBit PROC
;;;824      */
;;;825    void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
000000  f04f4220          MOV      r2,#0xa0000000
;;;826    {
;;;827      /* Check the parameters */
;;;828      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;829      assert_param(IS_FSMC_IT(FSMC_IT));
;;;830        
;;;831      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d104              BNE      |L2.18|
;;;832      {
;;;833        FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
000008  6e50              LDR      r0,[r2,#0x64]
00000a  ea2000d1          BIC      r0,r0,r1,LSR #3
00000e  6650              STR      r0,[r2,#0x64]
;;;834      }  
;;;835      else if(FSMC_Bank == FSMC_Bank3_NAND)
;;;836      {
;;;837        FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
;;;838      }
;;;839      /* FSMC_Bank4_PCCARD*/
;;;840      else
;;;841      {
;;;842        FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
;;;843      }
;;;844    }
000010  4770              BX       lr
                  |L2.18|
000012  f5b07f80          CMP      r0,#0x100             ;835
000016  d101              BNE      |L2.28|
000018  3284              ADDS     r2,r2,#0x84           ;835
00001a  e000              B        |L2.30|
                  |L2.28|
00001c  32a4              ADDS     r2,r2,#0xa4           ;837
                  |L2.30|
00001e  6810              LDR      r0,[r2,#0]            ;842
000020  ea2000d1          BIC      r0,r0,r1,LSR #3       ;842
000024  6010              STR      r0,[r2,#0]            ;842
000026  4770              BX       lr
;;;845    
                          ENDP


                          AREA ||i.FSMC_GetECC||, CODE, READONLY, ALIGN=1

                  FSMC_GetECC PROC
;;;594      */
;;;595    uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
000000  f04f4120          MOV      r1,#0xa0000000
;;;596    {
;;;597      uint32_t eccval = 0x00000000;
;;;598      
;;;599      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d101              BNE      |L3.12|
;;;600      {
;;;601        /* Get the ECCR2 register value */
;;;602        eccval = FSMC_Bank2->ECCR2;
000008  6f48              LDR      r0,[r1,#0x74]
;;;603      }
;;;604      else
;;;605      {
;;;606        /* Get the ECCR3 register value */
;;;607        eccval = FSMC_Bank3->ECCR3;
;;;608      }
;;;609      /* Return the error correction code value */
;;;610      return(eccval);
;;;611    }
00000a  4770              BX       lr
                  |L3.12|
00000c  f8d10094          LDR      r0,[r1,#0x94]         ;607
000010  4770              BX       lr
;;;612    
                          ENDP


                          AREA ||i.FSMC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  FSMC_GetFlagStatus PROC
;;;688      */
;;;689    FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000000  4603              MOV      r3,r0
;;;690    {
;;;691      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;692      uint32_t tmpsr = 0x00000000;
;;;693      
;;;694      /* Check the parameters */
;;;695      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;696      assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
;;;697      
;;;698      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;699      {
;;;700        tmpsr = FSMC_Bank2->SR2;
000004  f04f4220          MOV      r2,#0xa0000000
000008  2b10              CMP      r3,#0x10              ;698
00000a  d101              BNE      |L4.16|
00000c  6e52              LDR      r2,[r2,#0x64]
00000e  e007              B        |L4.32|
                  |L4.16|
;;;701      }  
;;;702      else if(FSMC_Bank == FSMC_Bank3_NAND)
000010  f5b37f80          CMP      r3,#0x100
000014  d102              BNE      |L4.28|
;;;703      {
;;;704        tmpsr = FSMC_Bank3->SR3;
000016  f8d22084          LDR      r2,[r2,#0x84]
00001a  e001              B        |L4.32|
                  |L4.28|
;;;705      }
;;;706      /* FSMC_Bank4_PCCARD*/
;;;707      else
;;;708      {
;;;709        tmpsr = FSMC_Bank4->SR4;
00001c  f8d220a4          LDR      r2,[r2,#0xa4]
                  |L4.32|
;;;710      } 
;;;711      
;;;712      /* Get the flag status */
;;;713      if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
000020  420a              TST      r2,r1
000022  d000              BEQ      |L4.38|
;;;714      {
;;;715        bitstatus = SET;
000024  2001              MOVS     r0,#1
                  |L4.38|
;;;716      }
;;;717      else
;;;718      {
;;;719        bitstatus = RESET;
;;;720      }
;;;721      /* Return the flag status */
;;;722      return bitstatus;
;;;723    }
000026  4770              BX       lr
;;;724    
                          ENDP


                          AREA ||i.FSMC_GetITStatus||, CODE, READONLY, ALIGN=1

                  FSMC_GetITStatus PROC
;;;773      */
;;;774    ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
000000  4603              MOV      r3,r0
;;;775    {
;;;776      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;777      uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
;;;778      
;;;779      /* Check the parameters */
;;;780      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;781      assert_param(IS_FSMC_GET_IT(FSMC_IT));
;;;782      
;;;783      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;784      {
;;;785        tmpsr = FSMC_Bank2->SR2;
000004  f04f4220          MOV      r2,#0xa0000000
000008  2b10              CMP      r3,#0x10              ;783
00000a  d101              BNE      |L5.16|
00000c  6e52              LDR      r2,[r2,#0x64]
00000e  e007              B        |L5.32|
                  |L5.16|
;;;786      }  
;;;787      else if(FSMC_Bank == FSMC_Bank3_NAND)
000010  f5b37f80          CMP      r3,#0x100
000014  d102              BNE      |L5.28|
;;;788      {
;;;789        tmpsr = FSMC_Bank3->SR3;
000016  f8d22084          LDR      r2,[r2,#0x84]
00001a  e001              B        |L5.32|
                  |L5.28|
;;;790      }
;;;791      /* FSMC_Bank4_PCCARD*/
;;;792      else
;;;793      {
;;;794        tmpsr = FSMC_Bank4->SR4;
00001c  f8d220a4          LDR      r2,[r2,#0xa4]
                  |L5.32|
;;;795      } 
;;;796      
;;;797      itstatus = tmpsr & FSMC_IT;
000020  420a              TST      r2,r1
;;;798      
;;;799      itenable = tmpsr & (FSMC_IT >> 3);
000022  ea0201d1          AND      r1,r2,r1,LSR #3
;;;800      if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
000026  d002              BEQ      |L5.46|
000028  2900              CMP      r1,#0
00002a  d000              BEQ      |L5.46|
;;;801      {
;;;802        bitstatus = SET;
00002c  2001              MOVS     r0,#1
                  |L5.46|
;;;803      }
;;;804      else
;;;805      {
;;;806        bitstatus = RESET;
;;;807      }
;;;808      return bitstatus; 
;;;809    }
00002e  4770              BX       lr
;;;810    
                          ENDP


                          AREA ||i.FSMC_ITConfig||, CODE, READONLY, ALIGN=1

                  FSMC_ITConfig PROC
;;;628      */
;;;629    void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;630    {
;;;631      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;632      assert_param(IS_FSMC_IT(FSMC_IT));	
;;;633      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;634      
;;;635      if (NewState != DISABLE)
;;;636      {
;;;637        /* Enable the selected FSMC_Bank2 interrupts */
;;;638        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;639        {
;;;640          FSMC_Bank2->SR2 |= FSMC_IT;
;;;641        }
;;;642        /* Enable the selected FSMC_Bank3 interrupts */
;;;643        else if (FSMC_Bank == FSMC_Bank3_NAND)
000002  f44f7480          MOV      r4,#0x100
000006  f04f4320          MOV      r3,#0xa0000000        ;640
00000a  b16a              CBZ      r2,|L6.40|
00000c  2810              CMP      r0,#0x10              ;638
00000e  d102              BNE      |L6.22|
000010  6e58              LDR      r0,[r3,#0x64]         ;640
000012  4308              ORRS     r0,r0,r1              ;640
000014  e00c              B        |L6.48|
                  |L6.22|
000016  42a0              CMP      r0,r4
000018  d101              BNE      |L6.30|
00001a  3384              ADDS     r3,r3,#0x84
;;;644        {
;;;645          FSMC_Bank3->SR3 |= FSMC_IT;
00001c  e000              B        |L6.32|
                  |L6.30|
00001e  33a4              ADDS     r3,r3,#0xa4
                  |L6.32|
;;;646        }
;;;647        /* Enable the selected FSMC_Bank4 interrupts */
;;;648        else
;;;649        {
;;;650          FSMC_Bank4->SR4 |= FSMC_IT;    
000020  6818              LDR      r0,[r3,#0]
000022  4308              ORRS     r0,r0,r1
                  |L6.36|
000024  6018              STR      r0,[r3,#0]
;;;651        }
;;;652      }
;;;653      else
;;;654      {
;;;655        /* Disable the selected FSMC_Bank2 interrupts */
;;;656        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;657        {
;;;658          
;;;659          FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
;;;660        }
;;;661        /* Disable the selected FSMC_Bank3 interrupts */
;;;662        else if (FSMC_Bank == FSMC_Bank3_NAND)
;;;663        {
;;;664          FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
;;;665        }
;;;666        /* Disable the selected FSMC_Bank4 interrupts */
;;;667        else
;;;668        {
;;;669          FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
;;;670        }
;;;671      }
;;;672    }
000026  bd10              POP      {r4,pc}
                  |L6.40|
000028  2810              CMP      r0,#0x10              ;656
00002a  d103              BNE      |L6.52|
00002c  6e58              LDR      r0,[r3,#0x64]         ;659
00002e  4388              BICS     r0,r0,r1              ;659
                  |L6.48|
000030  6658              STR      r0,[r3,#0x64]         ;640
000032  bd10              POP      {r4,pc}
                  |L6.52|
000034  42a0              CMP      r0,r4                 ;662
000036  d101              BNE      |L6.60|
000038  3384              ADDS     r3,r3,#0x84           ;662
00003a  e000              B        |L6.62|
                  |L6.60|
00003c  33a4              ADDS     r3,r3,#0xa4           ;664
                  |L6.62|
00003e  6818              LDR      r0,[r3,#0]            ;664
000040  4388              BICS     r0,r0,r1              ;664
000042  e7ef              B        |L6.36|
;;;673    
                          ENDP


                          AREA ||i.FSMC_NANDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDCmd PROC
;;;492      */
;;;493    void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;494    {
;;;495      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;496      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;497      
;;;498      if (NewState != DISABLE)
000004  b151              CBZ      r1,|L7.28|
;;;499      {
;;;500        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;501        if(FSMC_Bank == FSMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
000008  d103              BNE      |L7.18|
;;;502        {
;;;503          FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
00000a  6e10              LDR      r0,[r2,#0x60]
00000c  f0400004          ORR      r0,r0,#4
000010  e009              B        |L7.38|
                  |L7.18|
;;;504        }
;;;505        else
;;;506        {
;;;507          FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
000012  f8520f80          LDR      r0,[r2,#0x80]!
000016  f0400004          ORR      r0,r0,#4
00001a  e009              B        |L7.48|
                  |L7.28|
;;;508        }
;;;509      }
;;;510      else
;;;511      {
;;;512        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;513        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;514        {
;;;515          FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
00001c  4905              LDR      r1,|L7.52|
00001e  2810              CMP      r0,#0x10              ;513
000020  d103              BNE      |L7.42|
000022  6e10              LDR      r0,[r2,#0x60]
000024  4008              ANDS     r0,r0,r1
                  |L7.38|
000026  6610              STR      r0,[r2,#0x60]         ;503
;;;516        }
;;;517        else
;;;518        {
;;;519          FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
;;;520        }
;;;521      }
;;;522    }
000028  4770              BX       lr
                  |L7.42|
00002a  f8520f80          LDR      r0,[r2,#0x80]!        ;519
00002e  4008              ANDS     r0,r0,r1              ;519
                  |L7.48|
000030  6010              STR      r0,[r2,#0]            ;507
000032  4770              BX       lr
;;;523    
                          ENDP

                  |L7.52|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_NANDDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDDeInit PROC
;;;127      */
;;;128    void FSMC_NANDDeInit(uint32_t FSMC_Bank)
000000  b510              PUSH     {r4,lr}
;;;129    {
;;;130      /* Check the parameter */
;;;131      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;132      
;;;133      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;134      {
;;;135        /* Set the FSMC_Bank2 registers to their reset values */
;;;136        FSMC_Bank2->PCR2 = 0x00000018;
000002  2318              MOVS     r3,#0x18
;;;137        FSMC_Bank2->SR2 = 0x00000040;
000004  2440              MOVS     r4,#0x40
000006  f04f4120          MOV      r1,#0xa0000000        ;136
;;;138        FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
00000a  f04f32fc          MOV      r2,#0xfcfcfcfc
00000e  2810              CMP      r0,#0x10              ;133
000010  d104              BNE      |L8.28|
000012  660b              STR      r3,[r1,#0x60]         ;136
000014  664c              STR      r4,[r1,#0x64]         ;137
000016  668a              STR      r2,[r1,#0x68]
;;;139        FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
000018  66ca              STR      r2,[r1,#0x6c]
;;;140      }
;;;141      /* FSMC_Bank3_NAND */  
;;;142      else
;;;143      {
;;;144        /* Set the FSMC_Bank3 registers to their reset values */
;;;145        FSMC_Bank3->PCR3 = 0x00000018;
;;;146        FSMC_Bank3->SR3 = 0x00000040;
;;;147        FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
;;;148        FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
;;;149      }  
;;;150    }
00001a  bd10              POP      {r4,pc}
                  |L8.28|
00001c  f8413f80          STR      r3,[r1,#0x80]!        ;145
000020  604c              STR      r4,[r1,#4]            ;146
000022  608a              STR      r2,[r1,#8]            ;147
000024  60ca              STR      r2,[r1,#0xc]          ;148
000026  bd10              POP      {r4,pc}
;;;151    
                          ENDP


                          AREA ||i.FSMC_NANDECCCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDECCCmd PROC
;;;555      */
;;;556    void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;557    {
;;;558      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;559      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;560      
;;;561      if (NewState != DISABLE)
000004  b151              CBZ      r1,|L9.28|
;;;562      {
;;;563        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;564        if(FSMC_Bank == FSMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
000008  d103              BNE      |L9.18|
;;;565        {
;;;566          FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
00000a  6e10              LDR      r0,[r2,#0x60]
00000c  f0400040          ORR      r0,r0,#0x40
000010  e009              B        |L9.38|
                  |L9.18|
;;;567        }
;;;568        else
;;;569        {
;;;570          FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
000012  f8520f80          LDR      r0,[r2,#0x80]!
000016  f0400040          ORR      r0,r0,#0x40
00001a  e009              B        |L9.48|
                  |L9.28|
;;;571        }
;;;572      }
;;;573      else
;;;574      {
;;;575        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;576        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;577        {
;;;578          FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
00001c  4905              LDR      r1,|L9.52|
00001e  2810              CMP      r0,#0x10              ;576
000020  d103              BNE      |L9.42|
000022  6e10              LDR      r0,[r2,#0x60]
000024  4008              ANDS     r0,r0,r1
                  |L9.38|
000026  6610              STR      r0,[r2,#0x60]         ;566
;;;579        }
;;;580        else
;;;581        {
;;;582          FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
;;;583        }
;;;584      }
;;;585    }
000028  4770              BX       lr
                  |L9.42|
00002a  f8520f80          LDR      r0,[r2,#0x80]!        ;582
00002e  4008              ANDS     r0,r0,r1              ;582
                  |L9.48|
000030  6010              STR      r0,[r2,#0]            ;570
000032  4770              BX       lr
;;;586    
                          ENDP

                  |L9.52|
                          DCD      0x000fffbf

                          AREA ||i.FSMC_NANDInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDInit PROC
;;;255      */
;;;256    void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;257    {
;;;258      uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
;;;259        
;;;260      /* Check the parameters */
;;;261      assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
;;;262      assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
;;;263      assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
;;;264      assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
;;;265      assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
;;;266      assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
;;;267      assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
;;;268      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;269      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;270      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;271      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;272      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;273      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;274      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;275      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;276      
;;;277      /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
;;;278      tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
000002  e9d04202          LDRD     r4,r2,[r0,#8]
000006  6841              LDR      r1,[r0,#4]
000008  4321              ORRS     r1,r1,r4
00000a  e9d03404          LDRD     r3,r4,[r0,#0x10]
00000e  431a              ORRS     r2,r2,r3
000010  4311              ORRS     r1,r1,r2
000012  ea412344          ORR      r3,r1,r4,LSL #9
000016  e9d02106          LDRD     r2,r1,[r0,#0x18]
00001a  ea433242          ORR      r2,r3,r2,LSL #13
;;;279                PCR_MemoryType_NAND |
;;;280                FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
;;;281                FSMC_NANDInitStruct->FSMC_ECC |
;;;282                FSMC_NANDInitStruct->FSMC_ECCPageSize |
;;;283                (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
;;;284                (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
;;;285                
;;;286      /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
;;;287      tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
00001e  e8910038          LDM      r1,{r3-r5}
;;;288                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;289                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;290                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;291                
;;;292      /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;293      tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000022  68ce              LDR      r6,[r1,#0xc]
000024  042d              LSLS     r5,r5,#16             ;287
000026  ea432304          ORR      r3,r3,r4,LSL #8       ;287
00002a  6a01              LDR      r1,[r0,#0x20]
00002c  ea456506          ORR      r5,r5,r6,LSL #24      ;287
000030  432b              ORRS     r3,r3,r5              ;287
000032  e8910070          LDM      r1,{r4-r6}
000036  ea442405          ORR      r4,r4,r5,LSL #8
00003a  0435              LSLS     r5,r6,#16
;;;294                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;295                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;296                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
;;;297      
;;;298      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
00003c  68ce              LDR      r6,[r1,#0xc]
;;;299      {
;;;300        /* FSMC_Bank2_NAND registers configuration */
;;;301        FSMC_Bank2->PCR2 = tmppcr;
00003e  6801              LDR      r1,[r0,#0]
000040  ea456506          ORR      r5,r5,r6,LSL #24      ;293
000044  432c              ORRS     r4,r4,r5              ;293
000046  f0420208          ORR      r2,r2,#8              ;278
00004a  f04f4020          MOV      r0,#0xa0000000
00004e  2910              CMP      r1,#0x10              ;298
000050  d103              BNE      |L10.90|
000052  6602              STR      r2,[r0,#0x60]
;;;302        FSMC_Bank2->PMEM2 = tmppmem;
000054  6683              STR      r3,[r0,#0x68]
;;;303        FSMC_Bank2->PATT2 = tmppatt;
000056  66c4              STR      r4,[r0,#0x6c]
;;;304      }
;;;305      else
;;;306      {
;;;307        /* FSMC_Bank3_NAND registers configuration */
;;;308        FSMC_Bank3->PCR3 = tmppcr;
;;;309        FSMC_Bank3->PMEM3 = tmppmem;
;;;310        FSMC_Bank3->PATT3 = tmppatt;
;;;311      }
;;;312    }
000058  bd70              POP      {r4-r6,pc}
                  |L10.90|
00005a  f8402f80          STR      r2,[r0,#0x80]!        ;308
00005e  6083              STR      r3,[r0,#8]            ;309
000060  60c4              STR      r4,[r0,#0xc]          ;310
000062  bd70              POP      {r4-r6,pc}
;;;313    
                          ENDP


                          AREA ||i.FSMC_NANDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDStructInit PROC
;;;409      */
;;;410    void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  2110              MOVS     r1,#0x10
;;;411    { 
;;;412      /* Reset NAND Init structure parameters values */
;;;413      FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
;;;414      FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
000002  6001              STR      r1,[r0,#0]
000004  2100              MOVS     r1,#0
;;;415      FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000006  6041              STR      r1,[r0,#4]
;;;416      FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
000008  6081              STR      r1,[r0,#8]
;;;417      FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
00000a  60c1              STR      r1,[r0,#0xc]
;;;418      FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
00000c  6101              STR      r1,[r0,#0x10]
;;;419      FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
00000e  6141              STR      r1,[r0,#0x14]
;;;420      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000010  6181              STR      r1,[r0,#0x18]
000012  69c2              LDR      r2,[r0,#0x1c]
000014  21fc              MOVS     r1,#0xfc
;;;421      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000016  6011              STR      r1,[r2,#0]
000018  69c2              LDR      r2,[r0,#0x1c]
;;;422      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00001a  6051              STR      r1,[r2,#4]
00001c  69c2              LDR      r2,[r0,#0x1c]
;;;423      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
00001e  6091              STR      r1,[r2,#8]
000020  69c2              LDR      r2,[r0,#0x1c]
;;;424      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000022  60d1              STR      r1,[r2,#0xc]
000024  6a02              LDR      r2,[r0,#0x20]
;;;425      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000026  6011              STR      r1,[r2,#0]
000028  6a02              LDR      r2,[r0,#0x20]
;;;426      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00002a  6051              STR      r1,[r2,#4]
00002c  6a02              LDR      r2,[r0,#0x20]
;;;427      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
00002e  6091              STR      r1,[r2,#8]
000030  6a00              LDR      r0,[r0,#0x20]
;;;428    }
000032  60c1              STR      r1,[r0,#0xc]
000034  4770              BX       lr
;;;429    
                          ENDP


                          AREA ||i.FSMC_NORSRAMCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMCmd PROC
;;;466      */
;;;467    void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;468    {
;;;469      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;470      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;471      
;;;472      if (NewState != DISABLE)
;;;473      {
;;;474        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;475        FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
000004  eb020080          ADD      r0,r2,r0,LSL #2
000008  2900              CMP      r1,#0                 ;472
00000a  6801              LDR      r1,[r0,#0]
00000c  d002              BEQ      |L12.20|
00000e  f0410101          ORR      r1,r1,#1
000012  e001              B        |L12.24|
                  |L12.20|
;;;476      }
;;;477      else
;;;478      {
;;;479        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;480        FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
000014  4a01              LDR      r2,|L12.28|
000016  4011              ANDS     r1,r1,r2
                  |L12.24|
000018  6001              STR      r1,[r0,#0]            ;475
;;;481      }
;;;482    }
00001a  4770              BX       lr
;;;483    
                          ENDP

                  |L12.28|
                          DCD      0x000ffffe

                          AREA ||i.FSMC_NORSRAMDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMDeInit PROC
;;;100      */
;;;101    void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
000000  f04f4220          MOV      r2,#0xa0000000
;;;102    {
;;;103      /* Check the parameter */
;;;104      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;105      
;;;106      /* FSMC_Bank1_NORSRAM1 */
;;;107      if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
;;;108      {
;;;109        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
;;;110      }
;;;111      /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
;;;112      else
;;;113      {   
;;;114        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
000004  eb020180          ADD      r1,r2,r0,LSL #2
000008  b918              CBNZ     r0,|L13.18|
00000a  f24300db          MOV      r0,#0x30db            ;109
00000e  6010              STR      r0,[r2,#0]            ;109
000010  e002              B        |L13.24|
                  |L13.18|
000012  f24300d2          MOV      r0,#0x30d2
000016  6008              STR      r0,[r1,#0]
                  |L13.24|
;;;115      }
;;;116      FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
000018  f06f4070          MVN      r0,#0xf0000000
00001c  6048              STR      r0,[r1,#4]
;;;117      FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
00001e  f8c10104          STR      r0,[r1,#0x104]
;;;118    }
000022  4770              BX       lr
;;;119    
                          ENDP


                          AREA ||i.FSMC_NORSRAMInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMInit PROC
;;;174      */
;;;175    void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  b5f0              PUSH     {r4-r7,lr}
;;;176    { 
;;;177      /* Check the parameters */
;;;178      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
;;;179      assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
;;;180      assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
;;;181      assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
;;;182      assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
;;;183      assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
;;;184      assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
;;;185      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
;;;186      assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
;;;187      assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
;;;188      assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
;;;189      assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
;;;190      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
;;;191      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
;;;192      assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
;;;193      assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;194      assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
;;;195      assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
;;;196      assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
;;;197      
;;;198      /* Bank1 NOR/SRAM control register configuration */ 
;;;199      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
000002  e9d03202          LDRD     r3,r2,[r0,#8]
000006  6841              LDR      r1,[r0,#4]
000008  4319              ORRS     r1,r1,r3
00000a  e9d04304          LDRD     r4,r3,[r0,#0x10]
00000e  4322              ORRS     r2,r2,r4
000010  4311              ORRS     r1,r1,r2
000012  4319              ORRS     r1,r1,r3
000014  e9d02306          LDRD     r2,r3,[r0,#0x18]
000018  4311              ORRS     r1,r1,r2
00001a  4319              ORRS     r1,r1,r3
00001c  e9d02308          LDRD     r2,r3,[r0,#0x20]
000020  4311              ORRS     r1,r1,r2
000022  4319              ORRS     r1,r1,r3
000024  e9d0230a          LDRD     r2,r3,[r0,#0x28]
000028  4311              ORRS     r1,r1,r2
00002a  6804              LDR      r4,[r0,#0]
00002c  4319              ORRS     r1,r1,r3
00002e  f04f4220          MOV      r2,#0xa0000000
000032  f8421024          STR      r1,[r2,r4,LSL #2]
;;;200                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
;;;201                FSMC_NORSRAMInitStruct->FSMC_MemoryType |
;;;202                FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
;;;203                FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
;;;204                FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
;;;205                FSMC_NORSRAMInitStruct->FSMC_WrapMode |
;;;206                FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
;;;207                FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
;;;208                FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
;;;209                FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
;;;210                FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
;;;211      if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
000036  6881              LDR      r1,[r0,#8]
000038  2908              CMP      r1,#8
00003a  d106              BNE      |L14.74|
;;;212      {
;;;213        FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;
00003c  6801              LDR      r1,[r0,#0]
00003e  eb020181          ADD      r1,r2,r1,LSL #2
000042  680b              LDR      r3,[r1,#0]
000044  f0430340          ORR      r3,r3,#0x40
000048  600b              STR      r3,[r1,#0]
                  |L14.74|
;;;214      }
;;;215      /* Bank1 NOR/SRAM timing register configuration */
;;;216      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
00004a  6b01              LDR      r1,[r0,#0x30]
00004c  e9d14301          LDRD     r4,r3,[r1,#4]
000050  021d              LSLS     r5,r3,#8
000052  680b              LDR      r3,[r1,#0]
000054  e9d16703          LDRD     r6,r7,[r1,#0xc]
000058  ea431304          ORR      r3,r3,r4,LSL #4
00005c  ea454506          ORR      r5,r5,r6,LSL #16
000060  432b              ORRS     r3,r3,r5
000062  e9d14505          LDRD     r4,r5,[r1,#0x14]
000066  ea435307          ORR      r3,r3,r7,LSL #20
00006a  ea436104          ORR      r1,r3,r4,LSL #24
00006e  6803              LDR      r3,[r0,#0]
000070  4329              ORRS     r1,r1,r5
000072  eb020383          ADD      r3,r2,r3,LSL #2
000076  6059              STR      r1,[r3,#4]
;;;217                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
;;;218                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
;;;219                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;220                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;221                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
;;;222                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
;;;223                 FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
;;;224                
;;;225        
;;;226      /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
;;;227      if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
000078  6a81              LDR      r1,[r0,#0x28]
00007a  f5b14f80          CMP      r1,#0x4000
00007e  d115              BNE      |L14.172|
;;;228      {
;;;229        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
;;;230        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
;;;231        assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
;;;232        assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
;;;233        assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
;;;234        assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
;;;235        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
000080  6b41              LDR      r1,[r0,#0x34]
000082  e9d14301          LDRD     r4,r3,[r1,#4]
000086  021d              LSLS     r5,r3,#8
000088  680b              LDR      r3,[r1,#0]
00008a  e9d16704          LDRD     r6,r7,[r1,#0x10]
00008e  ea431304          ORR      r3,r3,r4,LSL #4
000092  ea455406          ORR      r4,r5,r6,LSL #20
000096  6989              LDR      r1,[r1,#0x18]
000098  4323              ORRS     r3,r3,r4
00009a  6800              LDR      r0,[r0,#0]
00009c  ea436307          ORR      r3,r3,r7,LSL #24
0000a0  430b              ORRS     r3,r3,r1
0000a2  eb020080          ADD      r0,r2,r0,LSL #2
0000a6  f8c03104          STR      r3,[r0,#0x104]
;;;236                  (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
;;;237                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
;;;238                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;239                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
;;;240                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
;;;241                   FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
;;;242      }
;;;243      else
;;;244      {
;;;245        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
;;;246      }
;;;247    }
0000aa  bdf0              POP      {r4-r7,pc}
                  |L14.172|
0000ac  6800              LDR      r0,[r0,#0]            ;245
0000ae  f06f4170          MVN      r1,#0xf0000000        ;245
0000b2  eb020080          ADD      r0,r2,r0,LSL #2       ;245
0000b6  f8c01104          STR      r1,[r0,#0x104]        ;245
0000ba  bdf0              POP      {r4-r7,pc}
;;;248    
                          ENDP


                          AREA ||i.FSMC_NORSRAMStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMStructInit PROC
;;;372      */
;;;373    void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  b510              PUSH     {r4,lr}
;;;374    {  
;;;375      /* Reset NOR/SRAM Init structure parameters values */
;;;376      FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
000002  2300              MOVS     r3,#0
;;;377      FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
000004  2102              MOVS     r1,#2
;;;378      FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
000006  e9c03100          STRD     r3,r1,[r0,#0]
;;;379      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
00000a  6083              STR      r3,[r0,#8]
;;;380      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
00000c  60c3              STR      r3,[r0,#0xc]
;;;381      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
00000e  6103              STR      r3,[r0,#0x10]
;;;382      FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
000010  6143              STR      r3,[r0,#0x14]
;;;383      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
000012  6183              STR      r3,[r0,#0x18]
;;;384      FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000014  02c9              LSLS     r1,r1,#11
;;;385      FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
000016  e9c03107          STRD     r3,r1,[r0,#0x1c]
00001a  0049              LSLS     r1,r1,#1
;;;386      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
;;;387      FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
00001c  e9c01309          STRD     r1,r3,[r0,#0x24]
;;;388      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000020  62c3              STR      r3,[r0,#0x2c]
000022  6b02              LDR      r2,[r0,#0x30]
000024  210f              MOVS     r1,#0xf
;;;389      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000026  6011              STR      r1,[r2,#0]
000028  6b02              LDR      r2,[r0,#0x30]
;;;390      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
00002a  24ff              MOVS     r4,#0xff
00002c  6051              STR      r1,[r2,#4]
00002e  6b02              LDR      r2,[r0,#0x30]
;;;391      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
000030  6094              STR      r4,[r2,#8]
000032  6b02              LDR      r2,[r0,#0x30]
;;;392      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
000034  60d1              STR      r1,[r2,#0xc]
000036  6b02              LDR      r2,[r0,#0x30]
;;;393      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
000038  6111              STR      r1,[r2,#0x10]
00003a  6b02              LDR      r2,[r0,#0x30]
;;;394      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
00003c  6151              STR      r1,[r2,#0x14]
00003e  6b02              LDR      r2,[r0,#0x30]
;;;395      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000040  6193              STR      r3,[r2,#0x18]
000042  6b42              LDR      r2,[r0,#0x34]
;;;396      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000044  6011              STR      r1,[r2,#0]
000046  6b42              LDR      r2,[r0,#0x34]
;;;397      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
000048  6051              STR      r1,[r2,#4]
00004a  6b42              LDR      r2,[r0,#0x34]
;;;398      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
00004c  6094              STR      r4,[r2,#8]
00004e  6b42              LDR      r2,[r0,#0x34]
;;;399      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
000050  60d1              STR      r1,[r2,#0xc]
000052  6b42              LDR      r2,[r0,#0x34]
;;;400      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
000054  6111              STR      r1,[r2,#0x10]
000056  6b42              LDR      r2,[r0,#0x34]
;;;401      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
000058  6151              STR      r1,[r2,#0x14]
00005a  6b40              LDR      r0,[r0,#0x34]
;;;402    }
00005c  6183              STR      r3,[r0,#0x18]
00005e  bd10              POP      {r4,pc}
;;;403    
                          ENDP


                          AREA ||i.FSMC_PCCARDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDCmd PROC
;;;529      */
;;;530    void FSMC_PCCARDCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L16.24|
;;;531    {
;;;532      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;533      
;;;534      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;535      {
;;;536        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;537        FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L16.14|
000008  f0400004          ORR      r0,r0,#4
00000c  e001              B        |L16.18|
                  |L16.14|
;;;538      }
;;;539      else
;;;540      {
;;;541        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;542        FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
00000e  4a03              LDR      r2,|L16.28|
000010  4010              ANDS     r0,r0,r2
                  |L16.18|
000012  6008              STR      r0,[r1,#0]            ;537
;;;543      }
;;;544    }
000014  4770              BX       lr
;;;545    
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      0xa00000a0
                  |L16.28|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_PCCARDDeInit||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDDeInit PROC
;;;156      */
;;;157    void FSMC_PCCARDDeInit(void)
000000  4805              LDR      r0,|L17.24|
;;;158    {
;;;159      /* Set the FSMC_Bank4 registers to their reset values */
;;;160      FSMC_Bank4->PCR4 = 0x00000018; 
000002  2118              MOVS     r1,#0x18
000004  6001              STR      r1,[r0,#0]
;;;161      FSMC_Bank4->SR4 = 0x00000000;	
000006  2100              MOVS     r1,#0
000008  6041              STR      r1,[r0,#4]
;;;162      FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
00000a  f04f31fc          MOV      r1,#0xfcfcfcfc
00000e  6081              STR      r1,[r0,#8]
;;;163      FSMC_Bank4->PATT4 = 0xFCFCFCFC;
000010  60c1              STR      r1,[r0,#0xc]
;;;164      FSMC_Bank4->PIO4 = 0xFCFCFCFC;
000012  6101              STR      r1,[r0,#0x10]
;;;165    }
000014  4770              BX       lr
;;;166    
                          ENDP

000016  0000              DCW      0x0000
                  |L17.24|
                          DCD      0xa00000a0

                          AREA ||i.FSMC_PCCARDInit||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDInit PROC
;;;320      */
;;;321    void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;322    {
;;;323      /* Check the parameters */
;;;324      assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
;;;325      assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
;;;326      assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
;;;327     
;;;328      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;329      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;330      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;331      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;332      
;;;333      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;334      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;335      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;336      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;337      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
;;;338      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
;;;339      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
;;;340      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
;;;341      
;;;342      /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
;;;343      FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
000002  e890000e          LDM      r0,{r1-r3}
000006  2410              MOVS     r4,#0x10
000008  ea412142          ORR      r1,r1,r2,LSL #9
00000c  ea443343          ORR      r3,r4,r3,LSL #13
000010  4a13              LDR      r2,|L18.96|
000012  4319              ORRS     r1,r1,r3
000014  6011              STR      r1,[r2,#0]
;;;344                         FSMC_MemoryDataWidth_16b |  
;;;345                         (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
;;;346                         (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
;;;347                
;;;348      /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
;;;349      FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000016  68c1              LDR      r1,[r0,#0xc]
000018  e9d13401          LDRD     r3,r4,[r1,#4]
00001c  680d              LDR      r5,[r1,#0]
00001e  68ce              LDR      r6,[r1,#0xc]
000020  0424              LSLS     r4,r4,#16
000022  ea452103          ORR      r1,r5,r3,LSL #8
000026  ea446306          ORR      r3,r4,r6,LSL #24
00002a  4319              ORRS     r1,r1,r3
00002c  6091              STR      r1,[r2,#8]
;;;350                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;351                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;352                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;353                
;;;354      /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;355      FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
00002e  6901              LDR      r1,[r0,#0x10]
000030  e9d13401          LDRD     r3,r4,[r1,#4]
000034  680d              LDR      r5,[r1,#0]
000036  68ce              LDR      r6,[r1,#0xc]
000038  0424              LSLS     r4,r4,#16
00003a  ea452103          ORR      r1,r5,r3,LSL #8
00003e  ea446306          ORR      r3,r4,r6,LSL #24
000042  4319              ORRS     r1,r1,r3
000044  60d1              STR      r1,[r2,#0xc]
;;;356                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;357                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;358                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
;;;359                
;;;360      /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
;;;361      FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
000046  6940              LDR      r0,[r0,#0x14]
000048  e9d01301          LDRD     r1,r3,[r0,#4]
00004c  6804              LDR      r4,[r0,#0]
00004e  68c5              LDR      r5,[r0,#0xc]
000050  041b              LSLS     r3,r3,#16
000052  ea442001          ORR      r0,r4,r1,LSL #8
000056  ea436105          ORR      r1,r3,r5,LSL #24
00005a  4308              ORRS     r0,r0,r1
00005c  6110              STR      r0,[r2,#0x10]
;;;362                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;363                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;364                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
;;;365    }
00005e  bd70              POP      {r4-r6,pc}
;;;366    
                          ENDP

                  |L18.96|
                          DCD      0xa00000a0

                          AREA ||i.FSMC_PCCARDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARDStructInit PROC
;;;435      */
;;;436    void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  2100              MOVS     r1,#0
;;;437    {
;;;438      /* Reset PCCARD Init structure parameters values */
;;;439      FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
;;;440      FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
000002  6001              STR      r1,[r0,#0]
;;;441      FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
000004  6041              STR      r1,[r0,#4]
;;;442      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000006  6081              STR      r1,[r0,#8]
000008  68c2              LDR      r2,[r0,#0xc]
00000a  21fc              MOVS     r1,#0xfc
;;;443      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00000c  6011              STR      r1,[r2,#0]
00000e  68c2              LDR      r2,[r0,#0xc]
;;;444      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000010  6051              STR      r1,[r2,#4]
000012  68c2              LDR      r2,[r0,#0xc]
;;;445      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000014  6091              STR      r1,[r2,#8]
000016  68c2              LDR      r2,[r0,#0xc]
;;;446      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000018  60d1              STR      r1,[r2,#0xc]
00001a  6902              LDR      r2,[r0,#0x10]
;;;447      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00001c  6011              STR      r1,[r2,#0]
00001e  6902              LDR      r2,[r0,#0x10]
;;;448      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000020  6051              STR      r1,[r2,#4]
000022  6902              LDR      r2,[r0,#0x10]
;;;449      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
000024  6091              STR      r1,[r2,#8]
000026  6902              LDR      r2,[r0,#0x10]
;;;450      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000028  60d1              STR      r1,[r2,#0xc]
00002a  6942              LDR      r2,[r0,#0x14]
;;;451      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00002c  6011              STR      r1,[r2,#0]
00002e  6942              LDR      r2,[r0,#0x14]
;;;452      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000030  6051              STR      r1,[r2,#4]
000032  6942              LDR      r2,[r0,#0x14]
;;;453      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000034  6091              STR      r1,[r2,#8]
000036  6940              LDR      r0,[r0,#0x14]
;;;454    }
000038  60c1              STR      r1,[r0,#0xc]
00003a  4770              BX       lr
;;;455    
                          ENDP

