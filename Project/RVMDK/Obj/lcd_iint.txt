; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\lcd_iint.o --depend=.\Obj\lcd_iint.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\User\inc -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -ID:\MDK4\ARM\INC -ID:\MDK4\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\lcd_iint.crf ..\..\User\src\LCD_Iint.c]
                          THUMB

                          AREA ||i.BGR2RGB||, CODE, READONLY, ALIGN=1

                  BGR2RGB PROC
;;;180    
;;;181    unsigned short BGR2RGB(unsigned short c)
000000  b530              PUSH     {r4,r5,lr}
;;;182    {
000002  4601              MOV      r1,r0
;;;183        u16  r, g, b, rgb;
;;;184    
;;;185        b = (c>>0)  & 0x1f;
000004  f001041f          AND      r4,r1,#0x1f
;;;186        g = (c>>5)  & 0x3f;
000008  f3c11345          UBFX     r3,r1,#5,#6
;;;187        r = (c>>11) & 0x1f;
00000c  0aca              LSRS     r2,r1,#11
;;;188    
;;;189        rgb =  (b<<11) + (g<<5) + (r<<0);
00000e  02e5              LSLS     r5,r4,#11
000010  eb051543          ADD      r5,r5,r3,LSL #5
000014  4415              ADD      r5,r5,r2
000016  b2a8              UXTH     r0,r5
;;;190    
;;;191        return( rgb );
;;;192    }
000018  bd30              POP      {r4,r5,pc}
;;;193    
                          ENDP


                          AREA ||i.delay||, CODE, READONLY, ALIGN=1

                  delay PROC
;;;25     
;;;26     static void delay(int cnt)
000000  4601              MOV      r1,r0
;;;27     {
;;;28         volatile unsigned int dl;
;;;29         while(cnt--)
000002  e005              B        |L2.16|
                  |L2.4|
;;;30         {
;;;31             for(dl=0; dl<500; dl++);
000004  2000              MOVS     r0,#0
000006  e000              B        |L2.10|
                  |L2.8|
000008  1c40              ADDS     r0,r0,#1
                  |L2.10|
00000a  f5b07ffa          CMP      r0,#0x1f4
00000e  d3fb              BCC      |L2.8|
                  |L2.16|
000010  000a              MOVS     r2,r1                 ;29
000012  f1a10101          SUB      r1,r1,#1              ;29
000016  d1f5              BNE      |L2.4|
;;;32         }
;;;33     }
000018  4770              BX       lr
;;;34     
                          ENDP


                          AREA ||i.lcd_Initializtion||, CODE, READONLY, ALIGN=2

                  lcd_Initializtion PROC
;;;223    
;;;224    void lcd_Initializtion(void)
000000  b510              PUSH     {r4,lr}
;;;225    {
;;;226        lcd_port_init();
000002  f7fffffe          BL       lcd_port_init
;;;227        delay(1500);
000006  f24050dc          MOV      r0,#0x5dc
00000a  f7fffffe          BL       delay
;;;228        deviceid = read_reg(0x00);
00000e  bf00              NOP      
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       write_cmd
000016  bf00              NOP      
000018  2000              MOVS     r0,#0
00001a  f44f5180          MOV      r1,#0x1000
00001e  4a7f              LDR      r2,|L3.540|
000020  6011              STR      r1,[r2,#0]
000022  f04f3144          MOV      r1,#0x44444444
000026  4a7e              LDR      r2,|L3.544|
000028  f8c21804          STR      r1,[r2,#0x804]
00002c  4a7d              LDR      r2,|L3.548|
00002e  6011              STR      r1,[r2,#0]
000030  f44f4100          MOV      r1,#0x8000
000034  4a7a              LDR      r2,|L3.544|
000036  f8c21414          STR      r1,[r2,#0x414]
00003a  4611              MOV      r1,r2
00003c  f8d11808          LDR      r1,[r1,#0x808]
000040  b288              UXTH     r0,r1
000042  4979              LDR      r1,|L3.552|
000044  6809              LDR      r1,[r1,#0]
000046  b288              UXTH     r0,r1
000048  f44f4100          MOV      r1,#0x8000
00004c  4a77              LDR      r2,|L3.556|
00004e  6011              STR      r1,[r2,#0]
000050  f04f3133          MOV      r1,#0x33333333
000054  4a76              LDR      r2,|L3.560|
000056  6011              STR      r1,[r2,#0]
000058  4a72              LDR      r2,|L3.548|
00005a  6011              STR      r1,[r2,#0]
00005c  f44f5180          MOV      r1,#0x1000
000060  4a6f              LDR      r2,|L3.544|
000062  f8c21410          STR      r1,[r2,#0x410]
000066  bf00              NOP      
000068  4604              MOV      r4,r0
00006a  bf00              NOP      
00006c  4871              LDR      r0,|L3.564|
00006e  8004              STRH     r4,[r0,#0]
;;;229    	
;;;230    	if( deviceid == 0x8989 )
000070  8800              LDRH     r0,[r0,#0]  ; deviceid
000072  f5a04109          SUB      r1,r0,#0x8900
000076  3989              SUBS     r1,r1,#0x89
000078  d17e              BNE      |L3.376|
;;;231        {
;;;232            // power supply setting
;;;233            // set R07h at 0021h (GON=1,DTE=0,D[1:0]=01)
;;;234            write_reg(0x0007,0x0021);
00007a  2121              MOVS     r1,#0x21
00007c  2007              MOVS     r0,#7
00007e  f7fffffe          BL       write_reg
;;;235            // set R00h at 0001h (OSCEN=1)
;;;236            write_reg(0x0000,0x0001);	
000082  2101              MOVS     r1,#1
000084  2000              MOVS     r0,#0
000086  f7fffffe          BL       write_reg
;;;237            // set R07h at 0023h (GON=1,DTE=0,D[1:0]=11)
;;;238            write_reg(0x0007,0x0023);
00008a  2123              MOVS     r1,#0x23
00008c  2007              MOVS     r0,#7
00008e  f7fffffe          BL       write_reg
;;;239            // set R10h at 0000h (Exit sleep mode)
;;;240            write_reg(0x0010,0x0000); 
000092  2100              MOVS     r1,#0
000094  2010              MOVS     r0,#0x10
000096  f7fffffe          BL       write_reg
;;;241            // Wait 30ms
;;;242            delay(3000);
00009a  f64030b8          MOV      r0,#0xbb8
00009e  f7fffffe          BL       delay
;;;243            // set R07h at 0033h (GON=1,DTE=1,D[1:0]=11)
;;;244            write_reg(0x0007,0x0033); 
0000a2  2133              MOVS     r1,#0x33
0000a4  2007              MOVS     r0,#7
0000a6  f7fffffe          BL       write_reg
;;;245            // Entry mode setting (R11h)
;;;246            // R11H Entry mode
;;;247            // vsmode DFM1 DFM0 TRANS OEDef WMode DMode1 DMode0 TY1 TY0 ID1 ID0 AM LG2 LG2 LG0
;;;248            //   0     1    1     0     0     0     0      0     0   1   1   1  *   0   0   0
;;;249            write_reg(0x0011,0x6070);
0000aa  f2460170          MOV      r1,#0x6070
0000ae  2011              MOVS     r0,#0x11
0000b0  f7fffffe          BL       write_reg
;;;250            // LCD driver AC setting (R02h)
;;;251            write_reg(0x0002,0x0600);
0000b4  f44f61c0          MOV      r1,#0x600
0000b8  2002              MOVS     r0,#2
0000ba  f7fffffe          BL       write_reg
;;;252            // power control 1
;;;253            // DCT3 DCT2 DCT1 DCT0 BT2 BT1 BT0 0 DC3 DC2 DC1 DC0 AP2 AP1 AP0 0
;;;254            // 1     0    1    0    1   0   0  0  1   0   1   0   0   1   0  0
;;;255            // DCT[3:0] fosc/4 BT[2:0]  DC{3:0] fosc/4
;;;256            write_reg(0x0003,0x0804);//0xA8A4
0000be  f6400104          MOV      r1,#0x804
0000c2  2003              MOVS     r0,#3
0000c4  f7fffffe          BL       write_reg
;;;257            write_reg(0x000C,0x0000);//
0000c8  2100              MOVS     r1,#0
0000ca  200c              MOVS     r0,#0xc
0000cc  f7fffffe          BL       write_reg
;;;258            write_reg(0x000D,0x080C);//
0000d0  f640010c          MOV      r1,#0x80c
0000d4  200d              MOVS     r0,#0xd
0000d6  f7fffffe          BL       write_reg
;;;259            // power control 4
;;;260            // 0 0 VCOMG VDV4 VDV3 VDV2 VDV1 VDV0 0 0 0 0 0 0 0 0
;;;261            // 0 0   1    0    1    0    1    1   0 0 0 0 0 0 0 0
;;;262            write_reg(0x000E,0x2900);
0000da  f44f5124          MOV      r1,#0x2900
0000de  200e              MOVS     r0,#0xe
0000e0  f7fffffe          BL       write_reg
;;;263            write_reg(0x001E,0x00B8);
0000e4  21b8              MOVS     r1,#0xb8
0000e6  201e              MOVS     r0,#0x1e
0000e8  f7fffffe          BL       write_reg
;;;264            write_reg(0x0001,0x2B3F);//驱动输出控制320*240  0x6B3F
0000ec  f642313f          MOV      r1,#0x2b3f
0000f0  2001              MOVS     r0,#1
0000f2  f7fffffe          BL       write_reg
;;;265            write_reg(0x0010,0x0000);
0000f6  2100              MOVS     r1,#0
0000f8  2010              MOVS     r0,#0x10
0000fa  f7fffffe          BL       write_reg
;;;266            write_reg(0x0005,0x0000);
0000fe  2100              MOVS     r1,#0
000100  2005              MOVS     r0,#5
000102  f7fffffe          BL       write_reg
;;;267            write_reg(0x0006,0x0000);
000106  2100              MOVS     r1,#0
000108  2006              MOVS     r0,#6
00010a  f7fffffe          BL       write_reg
;;;268            write_reg(0x0016,0xEF1C);
00010e  f64e711c          MOV      r1,#0xef1c
000112  2016              MOVS     r0,#0x16
000114  f7fffffe          BL       write_reg
;;;269            write_reg(0x0017,0x0003);
000118  2103              MOVS     r1,#3
00011a  2017              MOVS     r0,#0x17
00011c  f7fffffe          BL       write_reg
;;;270            write_reg(0x0007,0x0233);//0x0233
000120  f2402133          MOV      r1,#0x233
000124  2007              MOVS     r0,#7
000126  f7fffffe          BL       write_reg
;;;271            write_reg(0x000B,0x0000|(3<<6));
00012a  21c0              MOVS     r1,#0xc0
00012c  200b              MOVS     r0,#0xb
00012e  f7fffffe          BL       write_reg
;;;272            write_reg(0x000F,0x0000);//扫描开始地址
000132  2100              MOVS     r1,#0
000134  200f              MOVS     r0,#0xf
000136  f7fffffe          BL       write_reg
;;;273            write_reg(0x0041,0x0000);
00013a  2100              MOVS     r1,#0
00013c  2041              MOVS     r0,#0x41
00013e  f7fffffe          BL       write_reg
;;;274            write_reg(0x0042,0x0000);
000142  2100              MOVS     r1,#0
000144  2042              MOVS     r0,#0x42
000146  f7fffffe          BL       write_reg
;;;275            write_reg(0x0048,0x0000);
00014a  2100              MOVS     r1,#0
00014c  2048              MOVS     r0,#0x48
00014e  f7fffffe          BL       write_reg
;;;276            write_reg(0x0049,0x013F);
000152  f240113f          MOV      r1,#0x13f
000156  2049              MOVS     r0,#0x49
000158  f7fffffe          BL       write_reg
;;;277            write_reg(0x004A,0x0000);
00015c  2100              MOVS     r1,#0
00015e  204a              MOVS     r0,#0x4a
000160  f7fffffe          BL       write_reg
;;;278            write_reg(0x004B,0x0000);
000164  2100              MOVS     r1,#0
000166  204b              MOVS     r0,#0x4b
000168  f7fffffe          BL       write_reg
;;;279            write_reg(0x0044,0xEF00);
00016c  f44f416f          MOV      r1,#0xef00
000170  2044              MOVS     r0,#0x44
000172  f7fffffe          BL       write_reg
;;;280            write_reg(0x0045,0x0000);
000176  e000              B        |L3.378|
                  |L3.376|
000178  e04f              B        |L3.538|
                  |L3.378|
00017a  2100              MOVS     r1,#0
00017c  2045              MOVS     r0,#0x45
00017e  f7fffffe          BL       write_reg
;;;281            write_reg(0x0046,0x013F);
000182  f240113f          MOV      r1,#0x13f
000186  2046              MOVS     r0,#0x46
000188  f7fffffe          BL       write_reg
;;;282            write_reg(0x0030,0x0707);
00018c  f2407107          MOV      r1,#0x707
000190  2030              MOVS     r0,#0x30
000192  f7fffffe          BL       write_reg
;;;283            write_reg(0x0031,0x0204);
000196  f44f7101          MOV      r1,#0x204
00019a  2031              MOVS     r0,#0x31
00019c  f7fffffe          BL       write_reg
;;;284            write_reg(0x0032,0x0204);
0001a0  f44f7101          MOV      r1,#0x204
0001a4  2032              MOVS     r0,#0x32
0001a6  f7fffffe          BL       write_reg
;;;285            write_reg(0x0033,0x0502);
0001aa  f2405102          MOV      r1,#0x502
0001ae  2033              MOVS     r0,#0x33
0001b0  f7fffffe          BL       write_reg
;;;286            write_reg(0x0034,0x0507);
0001b4  f2405107          MOV      r1,#0x507
0001b8  2034              MOVS     r0,#0x34
0001ba  f7fffffe          BL       write_reg
;;;287            write_reg(0x0035,0x0204);
0001be  f44f7101          MOV      r1,#0x204
0001c2  2035              MOVS     r0,#0x35
0001c4  f7fffffe          BL       write_reg
;;;288            write_reg(0x0036,0x0204);
0001c8  f44f7101          MOV      r1,#0x204
0001cc  2036              MOVS     r0,#0x36
0001ce  f7fffffe          BL       write_reg
;;;289            write_reg(0x0037,0x0502);
0001d2  f2405102          MOV      r1,#0x502
0001d6  2037              MOVS     r0,#0x37
0001d8  f7fffffe          BL       write_reg
;;;290            write_reg(0x003A,0x0302);
0001dc  f2403102          MOV      r1,#0x302
0001e0  203a              MOVS     r0,#0x3a
0001e2  f7fffffe          BL       write_reg
;;;291            write_reg(0x003B,0x0302);
0001e6  f2403102          MOV      r1,#0x302
0001ea  203b              MOVS     r0,#0x3b
0001ec  f7fffffe          BL       write_reg
;;;292            write_reg(0x0023,0x0000);
0001f0  2100              MOVS     r1,#0
0001f2  2023              MOVS     r0,#0x23
0001f4  f7fffffe          BL       write_reg
;;;293            write_reg(0x0024,0x0000);
0001f8  2100              MOVS     r1,#0
0001fa  2024              MOVS     r0,#0x24
0001fc  f7fffffe          BL       write_reg
;;;294            write_reg(0x0025,0x8000);   // 65hz
000200  f44f4100          MOV      r1,#0x8000
000204  2025              MOVS     r0,#0x25
000206  f7fffffe          BL       write_reg
;;;295            write_reg(0x004f,0);        // 行首址0
00020a  2100              MOVS     r1,#0
00020c  204f              MOVS     r0,#0x4f
00020e  f7fffffe          BL       write_reg
;;;296            write_reg(0x004e,0);        // 列首址0	  
000212  2100              MOVS     r1,#0
000214  204e              MOVS     r0,#0x4e
000216  f7fffffe          BL       write_reg
                  |L3.538|
;;;297        }
;;;298    }
00021a  bd10              POP      {r4,pc}
;;;299    
                          ENDP

                  |L3.540|
                          DCD      0x40011414
                  |L3.544|
                          DCD      0x40011000
                  |L3.548|
                          DCD      0x40011800
                  |L3.552|
                          DCD      0x40011808
                  |L3.556|
                          DCD      0x40011410
                  |L3.560|
                          DCD      0x40011804
                  |L3.564|
                          DCD      deviceid

                          AREA ||i.lcd_SetCursor||, CODE, READONLY, ALIGN=2

                  lcd_SetCursor PROC
;;;193    
;;;194    void lcd_SetCursor(unsigned int x,unsigned int y)
000000  b570              PUSH     {r4-r6,lr}
;;;195    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;196        // SSD1289 控制器的屏使用不同的寄存器
;;;197        if( deviceid == 0x8989 )
000006  480b              LDR      r0,|L4.52|
000008  8800              LDRH     r0,[r0,#0]  ; deviceid
00000a  f5a04109          SUB      r1,r0,#0x8900
00000e  3989              SUBS     r1,r1,#0x89
000010  d107              BNE      |L4.34|
;;;198        {
;;;199            write_reg(0x004e,x);    /* 0-239 */
000012  b2a1              UXTH     r1,r4
000014  204e              MOVS     r0,#0x4e
000016  f7fffffe          BL       write_reg
;;;200            write_reg(0x004f,y);    /* 0-319 */
00001a  b2a9              UXTH     r1,r5
00001c  204f              MOVS     r0,#0x4f
00001e  f7fffffe          BL       write_reg
                  |L4.34|
;;;201        }
;;;202        write_reg(32,x);    /* 0-239 */
000022  b2a1              UXTH     r1,r4
000024  2020              MOVS     r0,#0x20
000026  f7fffffe          BL       write_reg
;;;203        write_reg(33,y);    /* 0-319 */
00002a  b2a9              UXTH     r1,r5
00002c  2021              MOVS     r0,#0x21
00002e  f7fffffe          BL       write_reg
;;;204    }
000032  bd70              POP      {r4-r6,pc}
;;;205    /****************************************************************************
                          ENDP

                  |L4.52|
                          DCD      deviceid

                          AREA ||i.lcd_clear||, CODE, READONLY, ALIGN=1

                  lcd_clear PROC
;;;212    ****************************************************************************/
;;;213    void lcd_clear(unsigned short Color)
000000  b570              PUSH     {r4-r6,lr}
;;;214    {
000002  4605              MOV      r5,r0
;;;215        unsigned int index=0;
000004  2400              MOVS     r4,#0
;;;216        lcd_SetCursor(0,0);
000006  2100              MOVS     r1,#0
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       lcd_SetCursor
;;;217        rw_data_prepare();                      /* Prepare to write GRAM */
00000e  f7fffffe          BL       rw_data_prepare
;;;218        for (index=0; index<(LCD_WIDTH*LCD_HEIGHT); index++)
000012  bf00              NOP      
000014  e003              B        |L5.30|
                  |L5.22|
;;;219        {
;;;220            write_data(Color);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       write_data
00001c  1c64              ADDS     r4,r4,#1              ;218
                  |L5.30|
00001e  f5b43f96          CMP      r4,#0x12c00           ;218
000022  d3f8              BCC      |L5.22|
;;;221        }
;;;222    }
000024  bd70              POP      {r4-r6,pc}
;;;223    
                          ENDP


                          AREA ||i.lcd_getdeviceid||, CODE, READONLY, ALIGN=2

                  lcd_getdeviceid PROC
;;;175    //返回LCD的ID
;;;176    unsigned int lcd_getdeviceid(void)
000000  4801              LDR      r0,|L6.8|
;;;177    {
;;;178        return deviceid;
000002  8800              LDRH     r0,[r0,#0]  ; deviceid
;;;179    }
000004  4770              BX       lr
;;;180    
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      deviceid

                          AREA ||i.lcd_port_init||, CODE, READONLY, ALIGN=2

                  lcd_port_init PROC
;;;47     
;;;48     static void lcd_port_init(void)
000000  b508              PUSH     {r3,lr}
;;;49     {
;;;50         GPIO_InitTypeDef GPIO_InitStructure;
;;;51         /*开启相应时钟 */
;;;52         RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB|
000002  2101              MOVS     r1,#1
000004  207c              MOVS     r0,#0x7c
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;53                                RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD|RCC_APB2Periph_GPIOE, ENABLE);
;;;54         /*所有Lcd引脚配置为推挽输出*/
;;;55         /*16位数据*/
;;;56         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
00000a  f64f70ff          MOV      r0,#0xffff
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;57         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000012  2003              MOVS     r0,#3
000014  f88d0002          STRB     r0,[sp,#2]
;;;58         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000018  2010              MOVS     r0,#0x10
00001a  f88d0003          STRB     r0,[sp,#3]
;;;59         GPIO_Init(GPIOE, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  480e              LDR      r0,|L7.92|
000022  f7fffffe          BL       GPIO_Init
;;;60         /*控制脚*/
;;;61         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15;
000026  f44f4070          MOV      r0,#0xf000
00002a  f8ad0000          STRH     r0,[sp,#0]
;;;62         GPIO_Init(GPIOD, &GPIO_InitStructure);
00002e  4669              MOV      r1,sp
000030  480b              LDR      r0,|L7.96|
000032  f7fffffe          BL       GPIO_Init
;;;63     
;;;64         set_CS();
000036  f44f5080          MOV      r0,#0x1000
00003a  490a              LDR      r1,|L7.100|
00003c  6008              STR      r0,[r1,#0]
;;;65         set_RS();
00003e  f44f5000          MOV      r0,#0x2000
000042  4909              LDR      r1,|L7.104|
000044  f8c10410          STR      r0,[r1,#0x410]
;;;66         set_nRD();
000048  f44f4000          MOV      r0,#0x8000
00004c  4905              LDR      r1,|L7.100|
00004e  6008              STR      r0,[r1,#0]
;;;67         set_nWR();
000050  f44f4080          MOV      r0,#0x4000
000054  4904              LDR      r1,|L7.104|
000056  f8c10410          STR      r0,[r1,#0x410]
;;;68     }
00005a  bd08              POP      {r3,pc}
;;;69     
                          ENDP

                  |L7.92|
                          DCD      0x40011800
                  |L7.96|
                          DCD      0x40011400
                  |L7.100|
                          DCD      0x40011410
                  |L7.104|
                          DCD      0x40011000

                          AREA ||i.rt_hw_lcd_draw_hline||, CODE, READONLY, ALIGN=1

                  rt_hw_lcd_draw_hline PROC
;;;333    /* 水平线 */
;;;334    void rt_hw_lcd_draw_hline(unsigned int colour, unsigned int x1, unsigned int x2, unsigned int y)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;335    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;336        /* [5:4]-ID~ID0 [3]-AM-1垂直-0水平 */
;;;337        write_reg(0x0003,(1<<12)|(1<<5)|(1<<4) | (0<<3) );
00000c  f2410130          MOV      r1,#0x1030
000010  2003              MOVS     r0,#3
000012  f7fffffe          BL       write_reg
;;;338    
;;;339        while (x1 < x2)
000016  e009              B        |L8.44|
                  |L8.24|
;;;340        {
;;;341            lcd_SetCursor(x1, y);
000018  4639              MOV      r1,r7
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       lcd_SetCursor
;;;342       		rw_data_prepare(); /* Prepare to write GRAM */
000020  f7fffffe          BL       rw_data_prepare
;;;343    		write_data(colour);
000024  b2a8              UXTH     r0,r5
000026  f7fffffe          BL       write_data
;;;344            x1++;
00002a  1c64              ADDS     r4,r4,#1
                  |L8.44|
00002c  42b4              CMP      r4,r6                 ;339
00002e  d3f3              BCC      |L8.24|
;;;345        }
;;;346    }
000030  e8bd81f0          POP      {r4-r8,pc}
;;;347    
                          ENDP


                          AREA ||i.rt_hw_lcd_draw_vline||, CODE, READONLY, ALIGN=1

                  rt_hw_lcd_draw_vline PROC
;;;348    /* 垂直线 */
;;;349    void rt_hw_lcd_draw_vline(unsigned int colour, unsigned int x, unsigned int y1, unsigned int y2)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;350    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
;;;351        /* [5:4]-ID~ID0 [3]-AM-1垂直-0水平 */
;;;352        write_reg(0x0003,(1<<12)|(1<<5)|(0<<4) | (1<<3) );
00000c  f2410128          MOV      r1,#0x1028
000010  2003              MOVS     r0,#3
000012  f7fffffe          BL       write_reg
;;;353    
;;;354        while (y1 < y2)
000016  e009              B        |L9.44|
                  |L9.24|
;;;355        {
;;;356            lcd_SetCursor(x, y1);
000018  4621              MOV      r1,r4
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       lcd_SetCursor
;;;357        	rw_data_prepare(); /* Prepare to write GRAM */
000020  f7fffffe          BL       rw_data_prepare
;;;358    		write_data(colour);
000024  b2a8              UXTH     r0,r5
000026  f7fffffe          BL       write_data
;;;359            y1++;	//每显示一色点坐标X会自动加1，但是坐标Y不会自动加1
00002a  1c64              ADDS     r4,r4,#1
                  |L9.44|
00002c  42bc              CMP      r4,r7                 ;354
00002e  d3f3              BCC      |L9.24|
;;;360        }
;;;361    }
000030  e8bd81f0          POP      {r4-r8,pc}
;;;362    
                          ENDP


                          AREA ||i.rw_data_prepare||, CODE, READONLY, ALIGN=1

                  rw_data_prepare PROC
;;;120    
;;;121    void rw_data_prepare(void)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123        write_cmd(0x22);
000002  2022              MOVS     r0,#0x22
000004  f7fffffe          BL       write_cmd
;;;124    }
000008  bd10              POP      {r4,pc}
;;;125    
                          ENDP


                          AREA ||i.write_cmd||, CODE, READONLY, ALIGN=2

                  write_cmd PROC
;;;69     
;;;70     lcd_inline void write_cmd(unsigned short cmd)
000000  f44f5180          MOV      r1,#0x1000
;;;71     {
;;;72         /**********************************
;;;73         // ** nCS      ---\________/------*
;;;74         // ** RS       ----\______/-------*
;;;75         // ** nRD      -------------------*
;;;76         // ** nWR      -----\___/---------*
;;;77         // ** DB[0-15] ------[###]--------*
;;;78         **********************************/
;;;79     
;;;80         clr_CS();
000004  4a0b              LDR      r2,|L11.52|
000006  6011              STR      r1,[r2,#0]
;;;81     
;;;82         clr_RS();
000008  f44f5100          MOV      r1,#0x2000
00000c  4a0a              LDR      r2,|L11.56|
00000e  f8c21414          STR      r1,[r2,#0x414]
;;;83         GPIOE->ODR = cmd;
000012  490a              LDR      r1,|L11.60|
000014  6008              STR      r0,[r1,#0]
;;;84         clr_nWR();
000016  f44f4180          MOV      r1,#0x4000
00001a  4a06              LDR      r2,|L11.52|
00001c  6011              STR      r1,[r2,#0]
;;;85         set_nWR();
00001e  f1a20204          SUB      r2,r2,#4
000022  6011              STR      r1,[r2,#0]
;;;86         set_RS();
000024  f44f5100          MOV      r1,#0x2000
000028  6011              STR      r1,[r2,#0]
;;;87     
;;;88         set_CS();
00002a  f44f5180          MOV      r1,#0x1000
00002e  6011              STR      r1,[r2,#0]
;;;89     }
000030  4770              BX       lr
;;;90     
                          ENDP

000032  0000              DCW      0x0000
                  |L11.52|
                          DCD      0x40011414
                  |L11.56|
                          DCD      0x40011000
                  |L11.60|
                          DCD      0x4001180c

                          AREA ||i.write_data||, CODE, READONLY, ALIGN=2

                  write_data PROC
;;;125    
;;;126    void write_data(unsigned short data )
000000  f44f5180          MOV      r1,#0x1000
;;;127    {
;;;128        /**********************************
;;;129        // ** nCS      ---\________/-----**
;;;130        // ** RS       ------------------**
;;;131        // ** nRD      ------------------**
;;;132        // ** nWR      -----\___/--------**
;;;133        // ** DB[0-15] ------[###]-------**
;;;134        **********************************/
;;;135        clr_CS();
000004  4a07              LDR      r2,|L12.36|
000006  6011              STR      r1,[r2,#0]
;;;136    
;;;137        GPIOE->ODR = data;
000008  4907              LDR      r1,|L12.40|
00000a  f8c1080c          STR      r0,[r1,#0x80c]
;;;138        clr_nWR();
00000e  f44f4180          MOV      r1,#0x4000
000012  6011              STR      r1,[r2,#0]
;;;139        set_nWR();
000014  f1a20204          SUB      r2,r2,#4
000018  6011              STR      r1,[r2,#0]
;;;140    
;;;141        set_CS();
00001a  f44f5180          MOV      r1,#0x1000
00001e  6011              STR      r1,[r2,#0]
;;;142    }
000020  4770              BX       lr
;;;143    
                          ENDP

000022  0000              DCW      0x0000
                  |L12.36|
                          DCD      0x40011414
                  |L12.40|
                          DCD      0x40011000

                          AREA ||i.write_reg||, CODE, READONLY, ALIGN=1

                  write_reg PROC
;;;143    
;;;144    lcd_inline void write_reg(unsigned char reg_addr,unsigned short reg_val)
000000  b570              PUSH     {r4-r6,lr}
;;;145    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;146        /*************************************************
;;;147        // ** nCS      ---\________/------\________/----**
;;;148        // ** RS       ----\______/---------------------**
;;;149        // ** nRD      ---------------------------------**
;;;150        // ** nWR      -----\___/-----------\___/-------**
;;;151        // ** DB[0-15] ------[###]-----------[###]------**
;;;152        *************************************************/
;;;153        write_cmd(reg_addr);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       write_cmd
;;;154        write_data(reg_val);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       write_data
;;;155    }
000012  bd70              POP      {r4-r6,pc}
;;;156    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  deviceid
000000  0000              DCW      0x0000
