; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\main.o --depend=.\Obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\User\inc -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -ID:\MDK4\ARM\INC -ID:\MDK4\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\main.crf ..\..\User\src\main.c]
                          THUMB

                          AREA ||i.EXTI_Configuration||, CODE, READONLY, ALIGN=1

                  EXTI_Configuration PROC
;;;159    
;;;160    void EXTI_Configuration(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;161    {
;;;162    	EXTI_InitTypeDef EXTI_InitStructure;
;;;163    	//选择GPIO管脚用作外部中断线路
;;;164    	GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource13);
000002  210d              MOVS     r1,#0xd
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       GPIO_EXTILineConfig
;;;165    	 
;;;166    	EXTI_InitStructure.EXTI_Line = EXTI_Line13;  //注意：选用的IO口是多少，就用Line多少
00000a  f44f5000          MOV      r0,#0x2000
00000e  9000              STR      r0,[sp,#0]
;;;167    	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; 
000010  2000              MOVS     r0,#0
000012  f88d0004          STRB     r0,[sp,#4]
;;;168    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
000016  200c              MOVS     r0,#0xc
000018  f88d0005          STRB     r0,[sp,#5]
;;;169    	EXTI_InitStructure.EXTI_LineCmd = ENABLE; 
00001c  2001              MOVS     r0,#1
00001e  f88d0006          STRB     r0,[sp,#6]
;;;170    	EXTI_Init(&EXTI_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       EXTI_Init
;;;171    }
000028  bd1c              POP      {r2-r4,pc}
;;;172    
                          ENDP


                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;44     /*IO配置*/
;;;45     void GPIO_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;46     {
;;;47         GPIO_InitTypeDef GPIO_InitStructure; 
;;;48          
;;;49         /*LED指示灯及输出38KHzIO配置*/
;;;50         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11;
000002  f44f6070          MOV      r0,#0xf00
000006  f8ad0000          STRH     r0,[sp,#0]
;;;51         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00000a  2010              MOVS     r0,#0x10
00000c  f88d0003          STRB     r0,[sp,#3]
;;;52         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000010  2003              MOVS     r0,#3
000012  f88d0002          STRB     r0,[sp,#2]
;;;53         GPIO_Init(GPIOD, &GPIO_InitStructure);
000016  4669              MOV      r1,sp
000018  480f              LDR      r0,|L2.88|
00001a  f7fffffe          BL       GPIO_Init
;;;54     
;;;55        	/*zlg7290按键中断输入配置*/
;;;56     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
00001e  f44f5000          MOV      r0,#0x2000
000022  f8ad0000          STRH     r0,[sp,#0]
;;;57         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000026  2003              MOVS     r0,#3
000028  f88d0002          STRB     r0,[sp,#2]
;;;58         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00002c  2004              MOVS     r0,#4
00002e  f88d0003          STRB     r0,[sp,#3]
;;;59         GPIO_Init(GPIOC, &GPIO_InitStructure);
000032  4669              MOV      r1,sp
000034  4809              LDR      r0,|L2.92|
000036  f7fffffe          BL       GPIO_Init
;;;60     
;;;61     	/*模拟I2C数据线和时钟线 PB6 SCL and PB7 SDA */  
;;;62     	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_6 | GPIO_Pin_7;
00003a  20c0              MOVS     r0,#0xc0
00003c  f8ad0000          STRH     r0,[sp,#0]
;;;63     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000040  2003              MOVS     r0,#3
000042  f88d0002          STRB     r0,[sp,#2]
;;;64     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //固件I2C协议必须用复用开漏输出GPIO_Mode_AF_OD，而模拟I2C用GPIO_Mode_Out_PP，否则不能不出脉冲
000046  2010              MOVS     r0,#0x10
000048  f88d0003          STRB     r0,[sp,#3]
;;;65     	GPIO_Init(GPIOB, &GPIO_InitStructure);
00004c  4669              MOV      r1,sp
00004e  4804              LDR      r0,|L2.96|
000050  f7fffffe          BL       GPIO_Init
;;;66     
;;;67     }
000054  bd08              POP      {r3,pc}
;;;68     
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      0x40011400
                  |L2.92|
                          DCD      0x40011000
                  |L2.96|
                          DCD      0x40010c00

                          AREA ||i.GPIO_ZLG7290_Config_OutPut||, CODE, READONLY, ALIGN=2

                  GPIO_ZLG7290_Config_OutPut PROC
;;;90     **************************************************************************/
;;;91     void GPIO_ZLG7290_Config_OutPut(void)//pb6=scl;  pb7=sda 
000000  b508              PUSH     {r3,lr}
;;;92     {
;;;93       GPIO_InitTypeDef GPIO_InitStructure;
;;;94       
;;;95       GPIO_InitStructure.GPIO_Pin =GPIO_Pin_6 |GPIO_Pin_7;//使能6~7
000002  20c0              MOVS     r0,#0xc0
000004  f8ad0000          STRH     r0,[sp,#0]
;;;96       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;      //推挽输出
000008  2010              MOVS     r0,#0x10
00000a  f88d0003          STRB     r0,[sp,#3]
;;;97       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;     //时钟为50MHz
00000e  2003              MOVS     r0,#3
000010  f88d0002          STRB     r0,[sp,#2]
;;;98       GPIO_Init(GPIOB, &GPIO_InitStructure);                //指向结构体中的变量
000014  4669              MOV      r1,sp
000016  4802              LDR      r0,|L3.32|
000018  f7fffffe          BL       GPIO_Init
;;;99     }
00001c  bd08              POP      {r3,pc}
;;;100    
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0x40010c00

                          AREA ||i.GPIO_ZLG7290_Config_PB7_InPut||, CODE, READONLY, ALIGN=2

                  GPIO_ZLG7290_Config_PB7_InPut PROC
;;;74     **************************************************************************/
;;;75     void GPIO_ZLG7290_Config_PB7_InPut(void)
000000  b508              PUSH     {r3,lr}
;;;76     {
;;;77       GPIO_InitTypeDef GPIO_InitStructure;
;;;78       
;;;79       GPIO_InitStructure.GPIO_Pin =GPIO_Pin_7;//使能5~7
000002  2080              MOVS     r0,#0x80
000004  f8ad0000          STRH     r0,[sp,#0]
;;;80       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;      //输入上拉/浮空输入均可
000008  2048              MOVS     r0,#0x48
00000a  f88d0003          STRB     r0,[sp,#3]
;;;81       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;     //时钟为50MHz
00000e  2003              MOVS     r0,#3
000010  f88d0002          STRB     r0,[sp,#2]
;;;82       GPIO_Init(GPIOB, &GPIO_InitStructure);                //指向结构体中的变量
000014  4669              MOV      r1,sp
000016  4802              LDR      r0,|L4.32|
000018  f7fffffe          BL       GPIO_Init
;;;83     }
00001c  bd08              POP      {r3,pc}
;;;84     
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x40010c00

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;107    */
;;;108    void NVIC_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;109    {
;;;110       NVIC_InitTypeDef NVIC_InitStructure;
;;;111     
;;;112       /* Enable the TIM2 gloabal Interrupt */
;;;113       NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
000002  201d              MOVS     r0,#0x1d
000004  f88d0000          STRB     r0,[sp,#0]
;;;114       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000008  2001              MOVS     r0,#1
00000a  f88d0001          STRB     r0,[sp,#1]
;;;115       NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
00000e  f88d0002          STRB     r0,[sp,#2]
;;;116       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000012  f88d0003          STRB     r0,[sp,#3]
;;;117       NVIC_Init(&NVIC_InitStructure);
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       NVIC_Init
;;;118    
;;;119       /* Enable the EXTI13 Interrupt */
;;;120       NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;	//注意9-5，和15-10的中断名称的表示
00001c  2028              MOVS     r0,#0x28
00001e  f88d0000          STRB     r0,[sp,#0]
;;;121       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000022  2000              MOVS     r0,#0
000024  f88d0001          STRB     r0,[sp,#1]
;;;122       NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000028  f88d0002          STRB     r0,[sp,#2]
;;;123       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00002c  2001              MOVS     r0,#1
00002e  f88d0003          STRB     r0,[sp,#3]
;;;124       NVIC_Init(&NVIC_InitStructure);
000032  4668              MOV      r0,sp
000034  f7fffffe          BL       NVIC_Init
;;;125    
;;;126       
;;;127    }
000038  bd08              POP      {r3,pc}
;;;128    
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=1

                  RCC_Configuration PROC
;;;32     /*开IO时钟*/
;;;33     void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;34     {
;;;35        /* TIM3 clock enable */
;;;36        RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
000002  2101              MOVS     r1,#1
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;37      
;;;38        /* GPIO_x clock enable */
;;;39        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO , ENABLE);
00000a  2101              MOVS     r1,#1
00000c  2039              MOVS     r0,#0x39
00000e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;40                               
;;;41     }
000012  bd10              POP      {r4,pc}
;;;42     
                          ENDP


                          AREA ||i.TIM_Configuration||, CODE, READONLY, ALIGN=2

                  TIM_Configuration PROC
;;;138    /*定时器TIM3配置*/
;;;139    void TIM_Configuration(void)  
000000  b510              PUSH     {r4,lr}
;;;140    {
;;;141    	/* Time base configuration */ 
;;;142       TIM_TimeBaseStructure.TIM_Period = 235; //周期（计数到该值后产生更新或中断，即定时时间到）
000002  20eb              MOVS     r0,#0xeb
000004  4909              LDR      r1,|L7.44|
000006  8088              STRH     r0,[r1,#4]
;;;143       TIM_TimeBaseStructure.TIM_Prescaler = 3; //设置了用来作为TIM3时钟频率除数的预分频值
000008  2003              MOVS     r0,#3
00000a  8008              STRH     r0,[r1,#0]
;;;144       			//这是计数周期的倍频计数器，相当于调节计数周期，可使Period尽量大，提高计数精度（该值越大，频率越小，周期越大）
;;;145    			/*  计数时钟 = 72M / (3+1) / (235+1) = 	76KHz(即13.15us进一次定时器中断)
;;;146    				所以一个周期的频率 = 76 / 2 = 38KHz */		        
;;;147       TIM_TimeBaseStructure.TIM_ClockDivision = 0;	//时钟分割
00000c  2000              MOVS     r0,#0
00000e  80c8              STRH     r0,[r1,#6]
;;;148       TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //向上计数
000010  8048              STRH     r0,[r1,#2]
;;;149       TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure); //基本初始化
000012  4807              LDR      r0,|L7.48|
000014  f7fffffe          BL       TIM_TimeBaseInit
;;;150    	
;;;151    	/* Prescaler configuration */
;;;152       //TIM_PrescalerConfig(TIM3, 7199, TIM_PSCReloadMode_Immediate);  //相当于TIM_Prescaler的值 
;;;153    
;;;154       TIM_ITConfig(TIM3, TIM_IT_Update , ENABLE );  //打开通道中断，中断需要这行代码（另外再配置NVIC中断即可）
000018  2201              MOVS     r2,#1
00001a  4611              MOV      r1,r2
00001c  4804              LDR      r0,|L7.48|
00001e  f7fffffe          BL       TIM_ITConfig
;;;155       //也可用TIM_ITConfig(TIM3, TIM_IT_CC1 , ENABLE ); //也可用其他通道，但是中断子函数也要相应改变
;;;156       /* TIM3 enable counter */
;;;157       TIM_Cmd(TIM3, ENABLE);  //启动定时器3
000022  2101              MOVS     r1,#1
000024  4802              LDR      r0,|L7.48|
000026  f7fffffe          BL       TIM_Cmd
;;;158    }
00002a  bd10              POP      {r4,pc}
;;;159    
                          ENDP

                  |L7.44|
                          DCD      TIM_TimeBaseStructure
                  |L7.48|
                          DCD      0x40000400

                          AREA ||i.delay||, CODE, READONLY, ALIGN=1

                  delay PROC
;;;25     /*延时，满足两次发送间的时间*/
;;;26     void delay(unsigned int num)
000000  bf00              NOP      
                  |L8.2|
;;;27     {
;;;28     	while(num--);	
000002  0001              MOVS     r1,r0
000004  f1a00001          SUB      r0,r0,#1
000008  d1fb              BNE      |L8.2|
;;;29     }
00000a  4770              BX       lr
;;;30     
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;177      */
;;;178    int main(void)
000000  2000              MOVS     r0,#0
;;;179    {
;;;180    	ZLG_flag = 0;
000002  490f              LDR      r1,|L9.64|
000004  6008              STR      r0,[r1,#0]  ; ZLG_flag
;;;181    	/* Setup STM32 system (clock, PLL and Flash configuration) */
;;;182    	SystemInit();
000006  f7fffffe          BL       SystemInit
;;;183    
;;;184    	/* Add your application code here	*/
;;;185    	RCC_Configuration();
00000a  f7fffffe          BL       RCC_Configuration
;;;186    	NVIC_Configuration();
00000e  f7fffffe          BL       NVIC_Configuration
;;;187      	GPIO_Configuration();
000012  f7fffffe          BL       GPIO_Configuration
;;;188    	TIM_Configuration();
000016  f7fffffe          BL       TIM_Configuration
;;;189    	EXTI_Configuration();
00001a  f7fffffe          BL       EXTI_Configuration
;;;190    
;;;191    	//LCD初始化		 
;;;192    	lcd_Initializtion(); 
00001e  f7fffffe          BL       lcd_Initializtion
;;;193    	lcd_clear(zise);	//背景色为紫色
000022  f64f001f          MOV      r0,#0xf81f
000026  f7fffffe          BL       lcd_clear
;;;194    	/* Infinite loop */
;;;195    	while (1)
00002a  e008              B        |L9.62|
                  |L9.44|
;;;196    	{
;;;197    		if(ZLG_flag == 1)
00002c  4804              LDR      r0,|L9.64|
00002e  6800              LDR      r0,[r0,#0]  ; ZLG_flag
000030  2801              CMP      r0,#1
000032  d104              BNE      |L9.62|
;;;198    		{
;;;199    			ZLG_flag=0;
000034  2000              MOVS     r0,#0
000036  4902              LDR      r1,|L9.64|
000038  6008              STR      r0,[r1,#0]  ; ZLG_flag
;;;200    			treat_zlg7290();
00003a  f7fffffe          BL       treat_zlg7290
                  |L9.62|
00003e  e7f5              B        |L9.44|
;;;201    			//delay(60000); //延时，满足两次发送间的时间
;;;202    		}
;;;203    	}
;;;204    }
;;;205    
                          ENDP

                  |L9.64|
                          DCD      ZLG_flag

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  TIM_TimeBaseStructure
                          %        10

                          AREA ||.data||, DATA, ALIGN=2

                  ZLG_flag
                          DCD      0x00000000

                  __ARM_use_no_argv EQU 0
