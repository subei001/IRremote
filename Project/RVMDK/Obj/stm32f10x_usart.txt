; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\stm32f10x_usart.o --depend=.\Obj\stm32f10x_usart.d --device=DARMSTM --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -IE:\keil_MDK\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_usart.c]
                          THUMB

                          AREA ||i.USART_ClearFlag||, CODE, READONLY, ALIGN=1

                  USART_ClearFlag PROC
;;;831      */
;;;832    void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  f4017200          AND      r2,r1,#0x200
;;;833    {
;;;834      /* Check the parameters */
;;;835      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;836      assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;837      /* The CTS flag is not available for UART4 and UART5 */
;;;838      if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
000004  f5b27f00          CMP      r2,#0x200
000008  d100              BNE      |L1.12|
;;;839      {
;;;840        assert_param(IS_USART_123_PERIPH(USARTx));
00000a  bf00              NOP      
                  |L1.12|
;;;841      } 
;;;842       
;;;843      USARTx->SR = (uint16_t)~USART_FLAG;
00000c  43ca              MVNS     r2,r1
00000e  8002              STRH     r2,[r0,#0]
;;;844    }
000010  4770              BX       lr
;;;845    
                          ENDP


                          AREA ||i.USART_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  USART_ClearITPendingBit PROC
;;;938      */
;;;939    void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  b510              PUSH     {r4,lr}
;;;940    {
;;;941      uint16_t bitpos = 0x00, itmask = 0x00;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
;;;942      /* Check the parameters */
;;;943      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;944      assert_param(IS_USART_CLEAR_IT(USART_IT));
;;;945      /* The CTS interrupt is not available for UART4 and UART5 */
;;;946      if (USART_IT == USART_IT_CTS)
000006  f5a16410          SUB      r4,r1,#0x900
00000a  3c6a              SUBS     r4,r4,#0x6a
00000c  d100              BNE      |L2.16|
;;;947      {
;;;948        assert_param(IS_USART_123_PERIPH(USARTx));
00000e  bf00              NOP      
                  |L2.16|
;;;949      }   
;;;950      
;;;951      bitpos = USART_IT >> 0x08;
000010  120a              ASRS     r2,r1,#8
;;;952      itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
000012  2401              MOVS     r4,#1
000014  4094              LSLS     r4,r4,r2
000016  b2a3              UXTH     r3,r4
;;;953      USARTx->SR = (uint16_t)~itmask;
000018  43dc              MVNS     r4,r3
00001a  8004              STRH     r4,[r0,#0]
;;;954    }
00001c  bd10              POP      {r4,pc}
;;;955    /**
                          ENDP


                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=1

                  USART_ClockInit PROC
;;;269      */
;;;270    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  b510              PUSH     {r4,lr}
;;;271    {
;;;272      uint32_t tmpreg = 0x00;
000002  2200              MOVS     r2,#0
;;;273      /* Check the parameters */
;;;274      assert_param(IS_USART_123_PERIPH(USARTx));
;;;275      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;276      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;277      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;278      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
;;;279      
;;;280    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;281      tmpreg = USARTx->CR2;
000004  8a02              LDRH     r2,[r0,#0x10]
;;;282      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;283      tmpreg &= CR2_CLOCK_CLEAR_Mask;
000006  f24f03ff          MOV      r3,#0xf0ff
00000a  401a              ANDS     r2,r2,r3
;;;284      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;285      /* Set CLKEN bit according to USART_Clock value */
;;;286      /* Set CPOL bit according to USART_CPOL value */
;;;287      /* Set CPHA bit according to USART_CPHA value */
;;;288      /* Set LBCL bit according to USART_LastBit value */
;;;289      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
00000c  880b              LDRH     r3,[r1,#0]
00000e  884c              LDRH     r4,[r1,#2]
000010  4323              ORRS     r3,r3,r4
000012  888c              LDRH     r4,[r1,#4]
000014  4323              ORRS     r3,r3,r4
000016  88cc              LDRH     r4,[r1,#6]
000018  4323              ORRS     r3,r3,r4
00001a  431a              ORRS     r2,r2,r3
;;;290                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;291      /* Write to USART CR2 */
;;;292      USARTx->CR2 = (uint16_t)tmpreg;
00001c  8202              STRH     r2,[r0,#0x10]
;;;293    }
00001e  bd10              POP      {r4,pc}
;;;294    
                          ENDP


                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;300      */
;;;301    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;302    {
;;;303      /* USART_ClockInitStruct members default value */
;;;304      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;305      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000004  8041              STRH     r1,[r0,#2]
;;;306      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000006  8081              STRH     r1,[r0,#4]
;;;307      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;308    }
00000a  4770              BX       lr
;;;309    
                          ENDP


                          AREA ||i.USART_Cmd||, CODE, READONLY, ALIGN=1

                  USART_Cmd PROC
;;;318      */
;;;319    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L5.12|
;;;320    {
;;;321      /* Check the parameters */
;;;322      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;323      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;324      
;;;325      if (NewState != DISABLE)
;;;326      {
;;;327        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;328        USARTx->CR1 |= CR1_UE_Set;
000002  8982              LDRH     r2,[r0,#0xc]
000004  f4425200          ORR      r2,r2,#0x2000
000008  8182              STRH     r2,[r0,#0xc]
00000a  e004              B        |L5.22|
                  |L5.12|
;;;329      }
;;;330      else
;;;331      {
;;;332        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;333        USARTx->CR1 &= CR1_UE_Reset;
00000c  8982              LDRH     r2,[r0,#0xc]
00000e  f64d73ff          MOV      r3,#0xdfff
000012  401a              ANDS     r2,r2,r3
000014  8182              STRH     r2,[r0,#0xc]
                  |L5.22|
;;;334      }
;;;335    }
000016  4770              BX       lr
;;;336    
                          ENDP


                          AREA ||i.USART_DMACmd||, CODE, READONLY, ALIGN=1

                  USART_DMACmd PROC
;;;414      */
;;;415    void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;416    {
;;;417      /* Check the parameters */
;;;418      assert_param(IS_USART_1234_PERIPH(USARTx));
;;;419      assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;420      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;421      if (NewState != DISABLE)
000002  b11a              CBZ      r2,|L6.12|
;;;422      {
;;;423        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;424           DMAR bits in the USART CR3 register */
;;;425        USARTx->CR3 |= USART_DMAReq;
000004  8a83              LDRH     r3,[r0,#0x14]
000006  430b              ORRS     r3,r3,r1
000008  8283              STRH     r3,[r0,#0x14]
00000a  e004              B        |L6.22|
                  |L6.12|
;;;426      }
;;;427      else
;;;428      {
;;;429        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;430           DMAR bits in the USART CR3 register */
;;;431        USARTx->CR3 &= (uint16_t)~USART_DMAReq;
00000c  8a83              LDRH     r3,[r0,#0x14]
00000e  43cc              MVNS     r4,r1
000010  b2a4              UXTH     r4,r4
000012  4023              ANDS     r3,r3,r4
000014  8283              STRH     r3,[r0,#0x14]
                  |L6.22|
;;;432      }
;;;433    }
000016  bd10              POP      {r4,pc}
;;;434    
                          ENDP


                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;119      */
;;;120    void USART_DeInit(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;121    {
000002  4604              MOV      r4,r0
;;;122      /* Check the parameters */
;;;123      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;124    
;;;125      if (USARTx == USART1)
000004  4820              LDR      r0,|L7.136|
000006  4284              CMP      r4,r0
000008  d109              BNE      |L7.30|
;;;126      {
;;;127        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0388              LSLS     r0,r1,#14
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;128        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000012  2100              MOVS     r1,#0
000014  f44f4080          MOV      r0,#0x4000
000018  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001c  e032              B        |L7.132|
                  |L7.30|
;;;129      }
;;;130      else if (USARTx == USART2)
00001e  481b              LDR      r0,|L7.140|
000020  4284              CMP      r4,r0
000022  d109              BNE      |L7.56|
;;;131      {
;;;132        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
000024  2101              MOVS     r1,#1
000026  0448              LSLS     r0,r1,#17
000028  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;133        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
00002c  2100              MOVS     r1,#0
00002e  f44f3000          MOV      r0,#0x20000
000032  f7fffffe          BL       RCC_APB1PeriphResetCmd
000036  e025              B        |L7.132|
                  |L7.56|
;;;134      }
;;;135      else if (USARTx == USART3)
000038  4815              LDR      r0,|L7.144|
00003a  4284              CMP      r4,r0
00003c  d109              BNE      |L7.82|
;;;136      {
;;;137        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
00003e  2101              MOVS     r1,#1
000040  0488              LSLS     r0,r1,#18
000042  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;138        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000046  2100              MOVS     r1,#0
000048  f44f2080          MOV      r0,#0x40000
00004c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000050  e018              B        |L7.132|
                  |L7.82|
;;;139      }    
;;;140      else if (USARTx == UART4)
000052  4810              LDR      r0,|L7.148|
000054  4284              CMP      r4,r0
000056  d109              BNE      |L7.108|
;;;141      {
;;;142        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
000058  2101              MOVS     r1,#1
00005a  04c8              LSLS     r0,r1,#19
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;143        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
000060  2100              MOVS     r1,#0
000062  f44f2000          MOV      r0,#0x80000
000066  f7fffffe          BL       RCC_APB1PeriphResetCmd
00006a  e00b              B        |L7.132|
                  |L7.108|
;;;144      }    
;;;145      else
;;;146      {
;;;147        if (USARTx == UART5)
00006c  480a              LDR      r0,|L7.152|
00006e  4284              CMP      r4,r0
000070  d108              BNE      |L7.132|
;;;148        { 
;;;149          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
000072  2101              MOVS     r1,#1
000074  0508              LSLS     r0,r1,#20
000076  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;150          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
00007a  2100              MOVS     r1,#0
00007c  f44f1080          MOV      r0,#0x100000
000080  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L7.132|
;;;151        }
;;;152      }
;;;153    }
000084  bd10              POP      {r4,pc}
;;;154    
                          ENDP

000086  0000              DCW      0x0000
                  |L7.136|
                          DCD      0x40013800
                  |L7.140|
                          DCD      0x40004400
                  |L7.144|
                          DCD      0x40004800
                  |L7.148|
                          DCD      0x40004c00
                  |L7.152|
                          DCD      0x40005000

                          AREA ||i.USART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  USART_GetFlagStatus PROC
;;;782      */
;;;783    FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  4602              MOV      r2,r0
;;;784    {
;;;785      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;786      /* Check the parameters */
;;;787      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;788      assert_param(IS_USART_FLAG(USART_FLAG));
;;;789      /* The CTS flag is not available for UART4 and UART5 */
;;;790      if (USART_FLAG == USART_FLAG_CTS)
000004  f5b17f00          CMP      r1,#0x200
000008  d100              BNE      |L8.12|
;;;791      {
;;;792        assert_param(IS_USART_123_PERIPH(USARTx));
00000a  bf00              NOP      
                  |L8.12|
;;;793      }  
;;;794      
;;;795      if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
00000c  8813              LDRH     r3,[r2,#0]
00000e  420b              TST      r3,r1
000010  d001              BEQ      |L8.22|
;;;796      {
;;;797        bitstatus = SET;
000012  2001              MOVS     r0,#1
000014  e000              B        |L8.24|
                  |L8.22|
;;;798      }
;;;799      else
;;;800      {
;;;801        bitstatus = RESET;
000016  2000              MOVS     r0,#0
                  |L8.24|
;;;802      }
;;;803      return bitstatus;
;;;804    }
000018  4770              BX       lr
;;;805    
                          ENDP


                          AREA ||i.USART_GetITStatus||, CODE, READONLY, ALIGN=1

                  USART_GetITStatus PROC
;;;864      */
;;;865    ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;866    {
000002  4602              MOV      r2,r0
;;;867      uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
000004  2300              MOVS     r3,#0
000006  2400              MOVS     r4,#0
000008  2500              MOVS     r5,#0
;;;868      ITStatus bitstatus = RESET;
00000a  2000              MOVS     r0,#0
;;;869      /* Check the parameters */
;;;870      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;871      assert_param(IS_USART_GET_IT(USART_IT));
;;;872      /* The CTS interrupt is not available for UART4 and UART5 */ 
;;;873      if (USART_IT == USART_IT_CTS)
00000c  f5a16610          SUB      r6,r1,#0x900
000010  3e6a              SUBS     r6,r6,#0x6a
000012  d100              BNE      |L9.22|
;;;874      {
;;;875        assert_param(IS_USART_123_PERIPH(USARTx));
000014  bf00              NOP      
                  |L9.22|
;;;876      }   
;;;877      
;;;878      /* Get the USART register index */
;;;879      usartreg = (((uint8_t)USART_IT) >> 0x05);
000016  f3c11542          UBFX     r5,r1,#5,#3
;;;880      /* Get the interrupt position */
;;;881      itmask = USART_IT & IT_Mask;
00001a  f001041f          AND      r4,r1,#0x1f
;;;882      itmask = (uint32_t)0x01 << itmask;
00001e  2601              MOVS     r6,#1
000020  fa06f404          LSL      r4,r6,r4
;;;883      
;;;884      if (usartreg == 0x01) /* The IT  is in CR1 register */
000024  2d01              CMP      r5,#1
000026  d102              BNE      |L9.46|
;;;885      {
;;;886        itmask &= USARTx->CR1;
000028  8996              LDRH     r6,[r2,#0xc]
00002a  4034              ANDS     r4,r4,r6
00002c  e006              B        |L9.60|
                  |L9.46|
;;;887      }
;;;888      else if (usartreg == 0x02) /* The IT  is in CR2 register */
00002e  2d02              CMP      r5,#2
000030  d102              BNE      |L9.56|
;;;889      {
;;;890        itmask &= USARTx->CR2;
000032  8a16              LDRH     r6,[r2,#0x10]
000034  4034              ANDS     r4,r4,r6
000036  e001              B        |L9.60|
                  |L9.56|
;;;891      }
;;;892      else /* The IT  is in CR3 register */
;;;893      {
;;;894        itmask &= USARTx->CR3;
000038  8a96              LDRH     r6,[r2,#0x14]
00003a  4034              ANDS     r4,r4,r6
                  |L9.60|
;;;895      }
;;;896      
;;;897      bitpos = USART_IT >> 0x08;
00003c  120b              ASRS     r3,r1,#8
;;;898      bitpos = (uint32_t)0x01 << bitpos;
00003e  2601              MOVS     r6,#1
000040  fa06f303          LSL      r3,r6,r3
;;;899      bitpos &= USARTx->SR;
000044  8816              LDRH     r6,[r2,#0]
000046  4033              ANDS     r3,r3,r6
;;;900      if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
000048  b114              CBZ      r4,|L9.80|
00004a  b10b              CBZ      r3,|L9.80|
;;;901      {
;;;902        bitstatus = SET;
00004c  2001              MOVS     r0,#1
00004e  e000              B        |L9.82|
                  |L9.80|
;;;903      }
;;;904      else
;;;905      {
;;;906        bitstatus = RESET;
000050  2000              MOVS     r0,#0
                  |L9.82|
;;;907      }
;;;908      
;;;909      return bitstatus;  
;;;910    }
000052  bd70              POP      {r4-r6,pc}
;;;911    
                          ENDP


                          AREA ||i.USART_HalfDuplexCmd||, CODE, READONLY, ALIGN=1

                  USART_HalfDuplexCmd PROC
;;;697      */
;;;698    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L10.12|
;;;699    {
;;;700      /* Check the parameters */
;;;701      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;702      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;703      
;;;704      if (NewState != DISABLE)
;;;705      {
;;;706        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;707        USARTx->CR3 |= CR3_HDSEL_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f0420208          ORR      r2,r2,#8
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L10.22|
                  |L10.12|
;;;708      }
;;;709      else
;;;710      {
;;;711        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;712        USARTx->CR3 &= CR3_HDSEL_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f64f73f7          MOV      r3,#0xfff7
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L10.22|
;;;713      }
;;;714    }
000016  4770              BX       lr
;;;715    
                          ENDP


                          AREA ||i.USART_ITConfig||, CODE, READONLY, ALIGN=1

                  USART_ITConfig PROC
;;;355      */
;;;356    void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
000000  b5f0              PUSH     {r4-r7,lr}
;;;357    {
;;;358      uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
000002  2400              MOVS     r4,#0
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;359      uint32_t usartxbase = 0x00;
000008  2300              MOVS     r3,#0
;;;360      /* Check the parameters */
;;;361      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;362      assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;363      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;364      /* The CTS interrupt is not available for UART4 and UART5 */
;;;365      if (USART_IT == USART_IT_CTS)
00000a  f5a16710          SUB      r7,r1,#0x900
00000e  3f6a              SUBS     r7,r7,#0x6a
000010  d100              BNE      |L11.20|
;;;366      {
;;;367        assert_param(IS_USART_123_PERIPH(USARTx));
000012  bf00              NOP      
                  |L11.20|
;;;368      }   
;;;369      
;;;370      usartxbase = (uint32_t)USARTx;
000014  4603              MOV      r3,r0
;;;371    
;;;372      /* Get the USART register index */
;;;373      usartreg = (((uint8_t)USART_IT) >> 0x05);
000016  f3c11442          UBFX     r4,r1,#5,#3
;;;374    
;;;375      /* Get the interrupt position */
;;;376      itpos = USART_IT & IT_Mask;
00001a  f001051f          AND      r5,r1,#0x1f
;;;377      itmask = (((uint32_t)0x01) << itpos);
00001e  2701              MOVS     r7,#1
000020  fa07f605          LSL      r6,r7,r5
;;;378        
;;;379      if (usartreg == 0x01) /* The IT is in CR1 register */
000024  2c01              CMP      r4,#1
000026  d101              BNE      |L11.44|
;;;380      {
;;;381        usartxbase += 0x0C;
000028  330c              ADDS     r3,r3,#0xc
00002a  e004              B        |L11.54|
                  |L11.44|
;;;382      }
;;;383      else if (usartreg == 0x02) /* The IT is in CR2 register */
00002c  2c02              CMP      r4,#2
00002e  d101              BNE      |L11.52|
;;;384      {
;;;385        usartxbase += 0x10;
000030  3310              ADDS     r3,r3,#0x10
000032  e000              B        |L11.54|
                  |L11.52|
;;;386      }
;;;387      else /* The IT is in CR3 register */
;;;388      {
;;;389        usartxbase += 0x14; 
000034  3314              ADDS     r3,r3,#0x14
                  |L11.54|
;;;390      }
;;;391      if (NewState != DISABLE)
000036  b11a              CBZ      r2,|L11.64|
;;;392      {
;;;393        *(__IO uint32_t*)usartxbase  |= itmask;
000038  681f              LDR      r7,[r3,#0]
00003a  4337              ORRS     r7,r7,r6
00003c  601f              STR      r7,[r3,#0]
00003e  e002              B        |L11.70|
                  |L11.64|
;;;394      }
;;;395      else
;;;396      {
;;;397        *(__IO uint32_t*)usartxbase &= ~itmask;
000040  681f              LDR      r7,[r3,#0]
000042  43b7              BICS     r7,r7,r6
000044  601f              STR      r7,[r3,#0]
                  |L11.70|
;;;398      }
;;;399    }
000046  bdf0              POP      {r4-r7,pc}
;;;400    
                          ENDP


                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;164      */
;;;165    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;166    {
000004  b086              SUB      sp,sp,#0x18
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;167      uint32_t tmpreg = 0x00, apbclock = 0x00;
00000a  2600              MOVS     r6,#0
00000c  2700              MOVS     r7,#0
;;;168      uint32_t integerdivider = 0x00;
00000e  bf00              NOP      
;;;169      uint32_t fractionaldivider = 0x00;
000010  bf00              NOP      
;;;170      uint32_t usartxbase = 0;
000012  46b2              MOV      r10,r6
;;;171      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;172      /* Check the parameters */
;;;173      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;174      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;175      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;176      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;177      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;178      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;179      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;180      /* The hardware flow control is available only for USART1, USART2 and USART3 */
;;;181      if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
000014  89a8              LDRH     r0,[r5,#0xc]
000016  b100              CBZ      r0,|L12.26|
;;;182      {
;;;183        assert_param(IS_USART_123_PERIPH(USARTx));
000018  bf00              NOP      
                  |L12.26|
;;;184      }
;;;185    
;;;186      usartxbase = (uint32_t)USARTx;
00001a  46a2              MOV      r10,r4
;;;187    
;;;188    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;189      tmpreg = USARTx->CR2;
00001c  8a26              LDRH     r6,[r4,#0x10]
;;;190      /* Clear STOP[13:12] bits */
;;;191      tmpreg &= CR2_STOP_CLEAR_Mask;
00001e  f64c70ff          MOV      r0,#0xcfff
000022  4006              ANDS     r6,r6,r0
;;;192      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;193      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;194      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
000024  88e8              LDRH     r0,[r5,#6]
000026  4306              ORRS     r6,r6,r0
;;;195      
;;;196      /* Write to USART CR2 */
;;;197      USARTx->CR2 = (uint16_t)tmpreg;
000028  8226              STRH     r6,[r4,#0x10]
;;;198    
;;;199    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;200      tmpreg = USARTx->CR1;
00002a  89a6              LDRH     r6,[r4,#0xc]
;;;201      /* Clear M, PCE, PS, TE and RE bits */
;;;202      tmpreg &= CR1_CLEAR_Mask;
00002c  f64e10f3          MOV      r0,#0xe9f3
000030  4006              ANDS     r6,r6,r0
;;;203      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;204      /* Set the M bits according to USART_WordLength value */
;;;205      /* Set PCE and PS bits according to USART_Parity value */
;;;206      /* Set TE and RE bits according to USART_Mode value */
;;;207      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
000032  88a8              LDRH     r0,[r5,#4]
000034  8929              LDRH     r1,[r5,#8]
000036  4308              ORRS     r0,r0,r1
000038  8969              LDRH     r1,[r5,#0xa]
00003a  4308              ORRS     r0,r0,r1
00003c  4306              ORRS     r6,r6,r0
;;;208                USART_InitStruct->USART_Mode;
;;;209      /* Write to USART CR1 */
;;;210      USARTx->CR1 = (uint16_t)tmpreg;
00003e  81a6              STRH     r6,[r4,#0xc]
;;;211    
;;;212    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;213      tmpreg = USARTx->CR3;
000040  8aa6              LDRH     r6,[r4,#0x14]
;;;214      /* Clear CTSE and RTSE bits */
;;;215      tmpreg &= CR3_CLEAR_Mask;
000042  f64f40ff          MOV      r0,#0xfcff
000046  4006              ANDS     r6,r6,r0
;;;216      /* Configure the USART HFC -------------------------------------------------*/
;;;217      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;218      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000048  89a8              LDRH     r0,[r5,#0xc]
00004a  4306              ORRS     r6,r6,r0
;;;219      /* Write to USART CR3 */
;;;220      USARTx->CR3 = (uint16_t)tmpreg;
00004c  82a6              STRH     r6,[r4,#0x14]
;;;221    
;;;222    /*---------------------------- USART BRR Configuration -----------------------*/
;;;223      /* Configure the USART Baud Rate -------------------------------------------*/
;;;224      RCC_GetClocksFreq(&RCC_ClocksStatus);
00004e  a801              ADD      r0,sp,#4
000050  f7fffffe          BL       RCC_GetClocksFreq
;;;225      if (usartxbase == USART1_BASE)
000054  4654              MOV      r4,r10
000056  4811              LDR      r0,|L12.156|
000058  4582              CMP      r10,r0
00005a  d101              BNE      |L12.96|
;;;226      {
;;;227        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
00005c  9f04              LDR      r7,[sp,#0x10]
00005e  e000              B        |L12.98|
                  |L12.96|
;;;228      }
;;;229      else
;;;230      {
;;;231        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
000060  9f03              LDR      r7,[sp,#0xc]
                  |L12.98|
;;;232      }
;;;233      /* Determine the integer part */
;;;234      integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct->USART_BaudRate)));
000062  eb0700c7          ADD      r0,r7,r7,LSL #3
000066  eb001007          ADD      r0,r0,r7,LSL #4
00006a  6829              LDR      r1,[r5,#0]
00006c  0089              LSLS     r1,r1,#2
00006e  fbb0f8f1          UDIV     r8,r0,r1
;;;235      tmpreg = (integerdivider / 0x64) << 0x04;
000072  2064              MOVS     r0,#0x64
000074  fbb8f0f0          UDIV     r0,r8,r0
000078  0106              LSLS     r6,r0,#4
;;;236      /* Determine the fractional part */
;;;237      fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
00007a  0930              LSRS     r0,r6,#4
00007c  2164              MOVS     r1,#0x64
00007e  fb018910          MLS      r9,r1,r0,r8
;;;238      tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((uint8_t)0x0F);
000082  2132              MOVS     r1,#0x32
000084  eb011009          ADD      r0,r1,r9,LSL #4
000088  2164              MOVS     r1,#0x64
00008a  fbb0f0f1          UDIV     r0,r0,r1
00008e  f000000f          AND      r0,r0,#0xf
000092  4306              ORRS     r6,r6,r0
;;;239      /* Write to USART BRR */
;;;240      USARTx->BRR = (uint16_t)tmpreg;
000094  8126              STRH     r6,[r4,#8]
;;;241    }
000096  b006              ADD      sp,sp,#0x18
000098  e8bd87f0          POP      {r4-r10,pc}
;;;242    
                          ENDP

                  |L12.156|
                          DCD      0x40013800

                          AREA ||i.USART_IrDACmd||, CODE, READONLY, ALIGN=1

                  USART_IrDACmd PROC
;;;745      */
;;;746    void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L13.12|
;;;747    {
;;;748      /* Check the parameters */
;;;749      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;750      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;751        
;;;752      if (NewState != DISABLE)
;;;753      {
;;;754        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;755        USARTx->CR3 |= CR3_IREN_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f0420202          ORR      r2,r2,#2
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L13.22|
                  |L13.12|
;;;756      }
;;;757      else
;;;758      {
;;;759        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;760        USARTx->CR3 &= CR3_IREN_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f64f73fd          MOV      r3,#0xfffd
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L13.22|
;;;761      }
;;;762    }
000016  4770              BX       lr
;;;763    
                          ENDP


                          AREA ||i.USART_IrDAConfig||, CODE, READONLY, ALIGN=1

                  USART_IrDAConfig PROC
;;;726      */
;;;727    void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
000000  8a82              LDRH     r2,[r0,#0x14]
;;;728    {
;;;729      /* Check the parameters */
;;;730      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;731      assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;732        
;;;733      USARTx->CR3 &= CR3_IRLP_Mask;
000002  f64f73fb          MOV      r3,#0xfffb
000006  401a              ANDS     r2,r2,r3
000008  8282              STRH     r2,[r0,#0x14]
;;;734      USARTx->CR3 |= USART_IrDAMode;
00000a  8a82              LDRH     r2,[r0,#0x14]
00000c  430a              ORRS     r2,r2,r1
00000e  8282              STRH     r2,[r0,#0x14]
;;;735    }
000010  4770              BX       lr
;;;736    
                          ENDP


                          AREA ||i.USART_LINBreakDetectLengthConfig||, CODE, READONLY, ALIGN=1

                  USART_LINBreakDetectLengthConfig PROC
;;;513      */
;;;514    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;515    {
;;;516      /* Check the parameters */
;;;517      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;518      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;519      
;;;520      USARTx->CR2 &= CR2_LBDL_Mask;
000002  f64f73df          MOV      r3,#0xffdf
000006  401a              ANDS     r2,r2,r3
000008  8202              STRH     r2,[r0,#0x10]
;;;521      USARTx->CR2 |= USART_LINBreakDetectLength;  
00000a  8a02              LDRH     r2,[r0,#0x10]
00000c  430a              ORRS     r2,r2,r1
00000e  8202              STRH     r2,[r0,#0x10]
;;;522    }
000010  4770              BX       lr
;;;523    
                          ENDP


                          AREA ||i.USART_LINCmd||, CODE, READONLY, ALIGN=1

                  USART_LINCmd PROC
;;;532      */
;;;533    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L16.12|
;;;534    {
;;;535      /* Check the parameters */
;;;536      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;537      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;538      
;;;539      if (NewState != DISABLE)
;;;540      {
;;;541        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;542        USARTx->CR2 |= CR2_LINEN_Set;
000002  8a02              LDRH     r2,[r0,#0x10]
000004  f4424280          ORR      r2,r2,#0x4000
000008  8202              STRH     r2,[r0,#0x10]
00000a  e004              B        |L16.22|
                  |L16.12|
;;;543      }
;;;544      else
;;;545      {
;;;546        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;547        USARTx->CR2 &= CR2_LINEN_Reset;
00000c  8a02              LDRH     r2,[r0,#0x10]
00000e  f64b73ff          MOV      r3,#0xbfff
000012  401a              ANDS     r2,r2,r3
000014  8202              STRH     r2,[r0,#0x10]
                  |L16.22|
;;;548      }
;;;549    }
000016  4770              BX       lr
;;;550    
                          ENDP


                          AREA ||i.USART_ReceiveData||, CODE, READONLY, ALIGN=1

                  USART_ReceiveData PROC
;;;575      */
;;;576    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000000  4601              MOV      r1,r0
;;;577    {
;;;578      /* Check the parameters */
;;;579      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;580      
;;;581      /* Receive Data */
;;;582      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
000002  8888              LDRH     r0,[r1,#4]
000004  f3c00008          UBFX     r0,r0,#0,#9
;;;583    }
000008  4770              BX       lr
;;;584    
                          ENDP


                          AREA ||i.USART_ReceiverWakeUpCmd||, CODE, READONLY, ALIGN=1

                  USART_ReceiverWakeUpCmd PROC
;;;484      */
;;;485    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L18.12|
;;;486    {
;;;487      /* Check the parameters */
;;;488      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;489      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;490      
;;;491      if (NewState != DISABLE)
;;;492      {
;;;493        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;494        USARTx->CR1 |= CR1_RWU_Set;
000002  8982              LDRH     r2,[r0,#0xc]
000004  f0420202          ORR      r2,r2,#2
000008  8182              STRH     r2,[r0,#0xc]
00000a  e004              B        |L18.22|
                  |L18.12|
;;;495      }
;;;496      else
;;;497      {
;;;498        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;499        USARTx->CR1 &= CR1_RWU_Reset;
00000c  8982              LDRH     r2,[r0,#0xc]
00000e  f64f73fd          MOV      r3,#0xfffd
000012  401a              ANDS     r2,r2,r3
000014  8182              STRH     r2,[r0,#0xc]
                  |L18.22|
;;;500      }
;;;501    }
000016  4770              BX       lr
;;;502    
                          ENDP


                          AREA ||i.USART_SendBreak||, CODE, READONLY, ALIGN=1

                  USART_SendBreak PROC
;;;591      */
;;;592    void USART_SendBreak(USART_TypeDef* USARTx)
000000  8981              LDRH     r1,[r0,#0xc]
;;;593    {
;;;594      /* Check the parameters */
;;;595      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;596      
;;;597      /* Send break characters */
;;;598      USARTx->CR1 |= CR1_SBK_Set;
000002  f0410101          ORR      r1,r1,#1
000006  8181              STRH     r1,[r0,#0xc]
;;;599    }
000008  4770              BX       lr
;;;600    
                          ENDP


                          AREA ||i.USART_SendData||, CODE, READONLY, ALIGN=1

                  USART_SendData PROC
;;;558      */
;;;559    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000000  f3c10208          UBFX     r2,r1,#0,#9
;;;560    {
;;;561      /* Check the parameters */
;;;562      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;563      assert_param(IS_USART_DATA(Data)); 
;;;564        
;;;565      /* Transmit Data */
;;;566      USARTx->DR = (Data & (uint16_t)0x01FF);
000004  8082              STRH     r2,[r0,#4]
;;;567    }
000006  4770              BX       lr
;;;568    
                          ENDP


                          AREA ||i.USART_SetAddress||, CODE, READONLY, ALIGN=1

                  USART_SetAddress PROC
;;;442      */
;;;443    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;444    {
;;;445      /* Check the parameters */
;;;446      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;447      assert_param(IS_USART_ADDRESS(USART_Address)); 
;;;448        
;;;449      /* Clear the USART address */
;;;450      USARTx->CR2 &= CR2_Address_Mask;
000002  f64f73f0          MOV      r3,#0xfff0
000006  401a              ANDS     r2,r2,r3
000008  8202              STRH     r2,[r0,#0x10]
;;;451      /* Set the USART address node */
;;;452      USARTx->CR2 |= USART_Address;
00000a  8a02              LDRH     r2,[r0,#0x10]
00000c  430a              ORRS     r2,r2,r1
00000e  8202              STRH     r2,[r0,#0x10]
;;;453    }
000010  4770              BX       lr
;;;454    
                          ENDP


                          AREA ||i.USART_SetGuardTime||, CODE, READONLY, ALIGN=1

                  USART_SetGuardTime PROC
;;;607      */
;;;608    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;609    {    
;;;610      /* Check the parameters */
;;;611      assert_param(IS_USART_123_PERIPH(USARTx));
;;;612      
;;;613      /* Clear the USART Guard time */
;;;614      USARTx->GTPR &= GTPR_LSB_Mask;
000002  b2d2              UXTB     r2,r2
000004  8302              STRH     r2,[r0,#0x18]
;;;615      /* Set the USART guard time */
;;;616      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
000006  8b02              LDRH     r2,[r0,#0x18]
000008  ea422201          ORR      r2,r2,r1,LSL #8
00000c  8302              STRH     r2,[r0,#0x18]
;;;617    }
00000e  4770              BX       lr
;;;618    
                          ENDP


                          AREA ||i.USART_SetPrescaler||, CODE, READONLY, ALIGN=1

                  USART_SetPrescaler PROC
;;;627      */
;;;628    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;629    { 
;;;630      /* Check the parameters */
;;;631      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;632      
;;;633      /* Clear the USART prescaler */
;;;634      USARTx->GTPR &= GTPR_MSB_Mask;
000002  f402427f          AND      r2,r2,#0xff00
000006  8302              STRH     r2,[r0,#0x18]
;;;635      /* Set the USART prescaler */
;;;636      USARTx->GTPR |= USART_Prescaler;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  430a              ORRS     r2,r2,r1
00000c  8302              STRH     r2,[r0,#0x18]
;;;637    }
00000e  4770              BX       lr
;;;638    
                          ENDP


                          AREA ||i.USART_SmartCardCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardCmd PROC
;;;646      */
;;;647    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L24.12|
;;;648    {
;;;649      /* Check the parameters */
;;;650      assert_param(IS_USART_123_PERIPH(USARTx));
;;;651      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;652      if (NewState != DISABLE)
;;;653      {
;;;654        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;655        USARTx->CR3 |= CR3_SCEN_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f0420220          ORR      r2,r2,#0x20
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L24.22|
                  |L24.12|
;;;656      }
;;;657      else
;;;658      {
;;;659        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;660        USARTx->CR3 &= CR3_SCEN_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f64f73df          MOV      r3,#0xffdf
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L24.22|
;;;661      }
;;;662    }
000016  4770              BX       lr
;;;663    
                          ENDP


                          AREA ||i.USART_SmartCardNACKCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardNACKCmd PROC
;;;671      */
;;;672    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L25.12|
;;;673    {
;;;674      /* Check the parameters */
;;;675      assert_param(IS_USART_123_PERIPH(USARTx));  
;;;676      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;677      if (NewState != DISABLE)
;;;678      {
;;;679        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;680        USARTx->CR3 |= CR3_NACK_Set;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  f0420210          ORR      r2,r2,#0x10
000008  8282              STRH     r2,[r0,#0x14]
00000a  e004              B        |L25.22|
                  |L25.12|
;;;681      }
;;;682      else
;;;683      {
;;;684        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;685        USARTx->CR3 &= CR3_NACK_Reset;
00000c  8a82              LDRH     r2,[r0,#0x14]
00000e  f64f73ef          MOV      r3,#0xffef
000012  401a              ANDS     r2,r2,r3
000014  8282              STRH     r2,[r0,#0x14]
                  |L25.22|
;;;686      }
;;;687    }
000016  4770              BX       lr
;;;688    
                          ENDP


                          AREA ||i.USART_StructInit||, CODE, READONLY, ALIGN=1

                  USART_StructInit PROC
;;;248      */
;;;249    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;250    {
;;;251      /* USART_InitStruct members default value */
;;;252      USART_InitStruct->USART_BaudRate = 9600;
000004  6001              STR      r1,[r0,#0]
;;;253      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;254      USART_InitStruct->USART_StopBits = USART_StopBits_1;
00000a  80c1              STRH     r1,[r0,#6]
;;;255      USART_InitStruct->USART_Parity = USART_Parity_No ;
00000c  8101              STRH     r1,[r0,#8]
;;;256      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00000e  210c              MOVS     r1,#0xc
000010  8141              STRH     r1,[r0,#0xa]
;;;257      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000012  2100              MOVS     r1,#0
000014  8181              STRH     r1,[r0,#0xc]
;;;258    }
000016  4770              BX       lr
;;;259    
                          ENDP


                          AREA ||i.USART_WakeUpConfig||, CODE, READONLY, ALIGN=1

                  USART_WakeUpConfig PROC
;;;465      */
;;;466    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
000000  8982              LDRH     r2,[r0,#0xc]
;;;467    {
;;;468      /* Check the parameters */
;;;469      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;470      assert_param(IS_USART_WAKEUP(USART_WakeUp));
;;;471      
;;;472      USARTx->CR1 &= CR1_WAKE_Mask;
000002  f24f73ff          MOV      r3,#0xf7ff
000006  401a              ANDS     r2,r2,r3
000008  8182              STRH     r2,[r0,#0xc]
;;;473      USARTx->CR1 |= USART_WakeUp;
00000a  8982              LDRH     r2,[r0,#0xc]
00000c  430a              ORRS     r2,r2,r1
00000e  8182              STRH     r2,[r0,#0xc]
;;;474    }
000010  4770              BX       lr
;;;475    
                          ENDP

